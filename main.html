<html>
<head>
  <title>VIDEO GLITCHING 3000 (VG3)</title>
  <link rel="icon" href="https://res.cloudinary.com/ft-bounty/image/upload/c_fill,g_auto/v1743057859568/nvft-user-files/production/5c590c13-7f05-4fcf-afca-111f9c43cc81/uploads/70accb76-7a4b-4b05-82e4-11f7b958b36e/original.octet-stream" type="image/x-icon">
  <style>
    body {
      background: #111;
      color: #0f0;
      font-family: monospace;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .container {
      max-width: 800px;
      width: 100%;
      padding: 20px;
    }

    .topbar {
      width: 100%;
      background-color: #000;
      border-bottom: 2px solid #0f0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 20px;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .logo {
      font-family: 'Courier New', monospace;
      font-weight: bold;
      font-size: 1.5em;
      color: #0f0;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 0 5px #0f0;
    }

    .tabs {
      display: flex;
      justify-content: center;
      gap: 20px;
    }

    .tab {
      color: #0f0;
      text-decoration: none;
      padding: 5px 15px;
      border: 1px solid #0f0;
      transition: all 0.3s;
    }

    .tab:hover {
      background: #0f0;
      color: #000;
    }

    .right-space {
      width: 150px;
    }

    #videoContainer {
      position: relative;
      margin: 20px 0;
      background: #000;
      border: 2px solid #0f0;
      min-height: 200px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #canvas {
      width: 100%;
      height: auto;
      display: block;
      max-width: 100%;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin: 20px 0;
      align-items: center;
    }

    button, input, select {
      background: #000;
      color: #0f0;
      border: 1px solid #0f0;
      padding: 10px;
      font-family: monospace;
      cursor: pointer;
      transition: all 0.3s;
    }

    button.active {
      background: #0f0;
      color: #000;
    }

    button:hover {
      background: #0f0;
      color: #000;
    }

    .glitch-animation {
      animation: glitch 0.2s infinite;
      position: relative;
      display: inline-block;
    }

    .glitch-animation::before,
    .glitch-animation::after {
      content: 'VIDEO GLITCHING 3000';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .glitch-animation::before {
      left: 2px;
      text-shadow: -1px 0 #ff00ff;
      clip: rect(44px, 450px, 56px, 0);
      animation: glitch-anim 5s infinite linear alternate-reverse;
    }

    .glitch-animation::after {
      left: -2px;
      text-shadow: -1px 0 #00ffff;
      clip: rect(44px, 450px, 56px, 0);
      animation: glitch-anim2 2s infinite linear alternate-reverse;
    }

    @keyframes glitch {
      0% { transform: translate(0) skew(0deg); }
      10% { transform: translate(-2px, 2px) skew(2deg); }
      20% { transform: translate(-2px, -2px) skew(-2deg); }
      30% { transform: translate(2px, 2px) skew(-2deg); }
      40% { transform: translate(2px, -2px) skew(3deg); }
      50% { transform: translate(-2px, 2px) skew(0deg); }
      60% { transform: translate(2px, -2px) skew(-3deg); }
      70% { transform: translate(-2px, -2px) skew(3deg); }
      80% { transform: translate(0) skew(0); }
      90% { transform: translate(2px, 2px) skew(-2deg); }
      100% { transform: translate(0) skew(0); }
    }

    @keyframes glitch-anim {
      0% { clip: rect(41px, 9999px, 25px, 0); }
      5% { clip: rect(17px, 9999px, 41px, 0); }
      10% { clip: rect(31px, 9999px, 12px, 0); }
      15% { clip: rect(75px, 9999px, 92px, 0); }
      20% { clip: rect(26px, 9999px, 48px, 0); }
      25% { clip: rect(38px, 9999px, 72px, 0); }
      30% { clip: rect(22px, 9999px, 62px, 0); }
      35% { clip: rect(31px, 9999px, 14px, 0); }
      40% { clip: rect(57px, 9999px, 73px, 0); }
      45% { clip: rect(25px, 9999px, 55px, 0); }
      50% { clip: rect(88px, 9999px, 32px, 0); }
      55% { clip: rect(21px, 9999px, 46px, 0); }
      60% { clip: rect(45px, 9999px, 16px, 0); }
      65% { clip: rect(66px, 9999px, 36px, 0); }
      70% { clip: rect(37px, 9999px, 75px, 0); }
      75% { clip: rect(51px, 9999px, 11px, 0); }
      80% { clip: rect(83px, 9999px, 49px, 0); }
      85% { clip: rect(23px, 9999px, 35px, 0); }
      90% { clip: rect(42px, 9999px, 67px, 0); }
      95% { clip: rect(33px, 9999px, 92px, 0); }
      100% { clip: rect(21px, 9999px, 67px, 0); }
    }

    @keyframes glitch-anim2 {
      0% { clip: rect(65px, 9999px, 45px, 0); }
      5% { clip: rect(24px, 9999px, 33px, 0); }
      10% { clip: rect(56px, 9999px, 22px, 0); }
      15% { clip: rect(12px, 9999px, 54px, 0); }
      20% { clip: rect(46px, 9999px, 65px, 0); }
      25% { clip: rect(34px, 9999px, 12px, 0); }
      30% { clip: rect(68px, 9999px, 25px, 0); }
      35% { clip: rect(27px, 9999px, 44px, 0); }
      40% { clip: rect(13px, 9999px, 63px, 0); }
      45% { clip: rect(56px, 9999px, 42px, 0); }
      50% { clip: rect(48px, 9999px, 16px, 0); }
      55% { clip: rect(83px, 9999px, 22px, 0); }
      60% { clip: rect(34px, 9999px, 58px, 0); }
      65% { clip: rect(16px, 9999px, 72px, 0); }
      70% { clip: rect(38px, 9999px, 19px, 0); }
      75% { clip: rect(59px, 9999px, 42px, 0); }
      80% { clip: rect(41px, 9999px, 65px, 0); }
      85% { clip: rect(63px, 9999px, 17px, 0); }
      90% { clip: rect(34px, 9999px, 59px, 0); }
      95% { clip: rect(27px, 9999px, 38px, 0); }
      100% { clip: rect(56px, 9999px, 41px, 0); }
    }

    /* ... existing code ... */
  </style>
</head>
<body>
  <div class="topbar">
    <div class="logo">VIDEO GLITCHING</div>
    <div class="tabs">
      <a href="https://video-glitching-2.vercel.app/" class="tab">Home</a>
      <a href="https://video-glitching-2.vercel.app/EXPLANATION.html" class="tab">Explanation</a>
      <a href="https://video-glitching-2.vercel.app/LICENSE.html" class="tab">License</a>
    </div>
    <div class="right-space"></div>
  </div>
  <div class="container">
    <h1 class="glitch-animation">VIDEO GLITCHING 3000</h1>
    <p id="instructions">Select a video file to begin. Audio effects will be enabled after video selection.</p>
    <input type="file" id="videoInput" accept="video/*">
    
    <div id="videoContainer">
      <canvas id="canvas"></canvas>
    </div>

    <h2 class="section-title">Video Effects</h2>
    <div class="controls">
      <button id="rgbSplit">RGB Split</button>
      <button id="noise">Noise</button>
      <button id="scanlines">Scanlines</button>
      <button id="pixelate">Pixelate</button>
      <button id="videoCrush">Video Crush</button>
      <button id="shuffle">Pixel Shuffle</button>
      <button id="rainbow">Rainbow</button>
      <button id="invert">Invert</button>
      <button id="desaturate">Desaturate</button>
      <button id="contrast">High Contrast</button>
      <button id="frameRandomizer">Frame Randomizer</button>
      <button id="lag">Lag</button>
      <button id="motionTrail">Motion Trail</button>
      <button id="redTint">Red Tint</button>
      <button id="videoStatic">Video Static</button>
      <button id="signalCorruption">Signal Corruption</button>
      <button id="dataMosh">Data Mosh</button>
      <button id="blocksGlitch">Blocks Glitch</button>
      <button id="tearingEffect">Screen Tearing</button>
      <button id="colorShift">Extreme Color Shift</button>
      <button id="ghosting">Digital Ghosting</button>
      <button id="chromaticAberration">Chromatic Aberration</button>
      <button id="waveform">Waveform Distortion</button>
      <button id="mirrorGlitch">Mirror Glitch</button>
      <button id="timeDisplacement">Time Displacement</button>
      <button id="pixelSort">Pixel Sort</button>
      <button id="compressionArtifacts">Compression Artifacts</button>
      <button id="glitchWalk">Glitch Walk</button>
      <button id="interlace">Digital Interlace</button>
      <button id="phosphor">Phosphor Burn</button>
      <button id="analogDrift">Analog Drift</button>
      <button id="vhsTracking">VHS Tracking</button>
      <button id="digitalTear">Digital Tear</button>
      <button id="acidWash">Acid Wash</button>
      <button id="plasmaWave">Plasma Wave</button>
      <button id="bitrot">Digital Bitrot</button>
      <button id="frequencyShift">Frequency Shift</button>
      <button id="analogBleed">Analog Bleed</button>
      <button id="timeStretch">Time Stretch</button>
      <button id="digitalSmear">Digital Smear</button>
      <button id="quantumGlitch">Quantum Glitch</button>
      <button id="fractalNoise">Fractal Noise</button>
      <button id="signalBleed">Signal Bleed</button>
      <button id="memoryLeak">Memory Leak</button>
      <button id="mathGlitch">Math Glitch</button>
      <button id="cellularAutomata">Cellular Automata</button>
      <button id="edgeDetection">Edge Detection</button>
      <button id="kaleidoscope">Kaleidoscope</button>
      <button id="oilPainting">Oil Painting</button>
      <button id="pixelBleed">Pixel Bleed</button>
      <button id="magneticField">Magnetic Field</button>
      <button id="energySpiral">Energy Spiral</button>
      <button id="quantumFlux">Quantum Flux</button>
      <button id="neonGlow">Neon Glow</button>
      <button id="liquidMetal">Liquid Metal</button>
      <button id="neuralGlitch">Neural Glitch</button>
      <button id="voronoiBreak">Voronoi Break</button>
      <button id="electricNoise">Electric Noise</button>
      <button id="subatomicShuffle">Subatomic Shuffle</button>
      <button id="rgbToYuv">RGB to YUV</button>
      <button id="yuvToRgb">YUV to RGB</button>
      <button id="cumulativeMath">Cumulative Math</button>
      <button id="literalSort">Literal Sort</button>
      <button id="lowPass">Low Pass</button>
      <button id="lumiSort">Lumi Sort</button>
      <button id="qamFault">QAM Fault</button>
      <button id="threeDDisplace">3D Displace</button>
      <button id="codeBlock">Code Block</button>
      <button id="tvNoise">TV Noise</button>
      <button id="vhsTape">VHS Tape</button>
      <button id="dataCorruption">Data Corruption</button>
      <button id="signalJammer">Signal Jammer</button>
      <button id="crtEffect">CRT Effect</button>
      <button id="filmGrain">Film Grain</button>
      <button id="oldMovie">Old Movie</button>
      <button id="fractalize">Fractalize</button>
      <button id="bloomEffect">Bloom Effect</button>
      <button id="deepfry">Deepfry</button>
      <button id="infrared">Infrared</button>
      <button id="nightVision">Night Vision</button>
      <button id="thermographics">Thermographics</button>
      <button id="radioWaves">Radio Waves</button>
      <button id="xray">X-Ray</button>
      <button id="vaporwave">Vaporwave</button>
      <button id="cyberpunk">Cyberpunk</button>
      <button id="glitchCore">Glitch Core</button>
      <button id="recursion">Recursion</button>
      <button id="pixelation3D">3D Pixelation</button>
      <button id="timeWarp">Time Warp</button>
      <button id="fourthDimension">Fourth Dimension</button>
      <button id="dataBending">Data Bending</button>
      <button id="circuitBreak">Circuit Break</button>
      <button id="machineCode">Machine Code</button>
      <button id="artifactGeneration">Artifact Generation</button>
      <button id="quantumEntanglement">Quantum Entanglement</button>
      <button id="matrixRain">Matrix Rain</button>
      <button id="hologramGlitch">Hologram Glitch</button>
      <button id="sinWave">Sin Wave</button>
      <button id="cosWave">Cos Wave</button>
      <button id="tanWave">Tan Wave</button>
      <button id="byteShift">Byte Shift</button>
      <button id="harmonicDistortion">Harmonic Distortion</button>
      <button id="cellularShift">Cellular Shift</button>
      <button id="digitalDecay">Digital Decay</button>
      <button id="fractalMosaic">Fractal Mosaic</button>
    </div>

    <div class="slider-container">
      <label for="staticAmount">Video Static Amount</label>
      <input type="range" id="staticAmount" min="0" max="100" value="0">
    </div>
    <div class="slider-container">
      <label for="rowShift">Row Shift</label>
      <input type="range" id="rowShift" min="-100" max="100" value="0">
    </div>
    <div class="slider-container">
      <label for="brightness">Brightness</label>
      <input type="range" id="brightness" min="-100" max="100" value="0">
    </div>
    <div class="slider-container">
      <label for="displayShift">Display Shift</label>
      <input type="range" id="displayShift" min="-100" max="100" value="0">
    </div>

    <h2 class="section-title">Audio Effects</h2>
    <div class="audio-controls">
      <div class="slider-container">
        <label for="distortion">Distortion</label>
        <input type="range" id="distortion" min="1" max="100" value="1">
      </div>
      <div class="slider-container">
        <label for="amplification">Amplification</label>
        <input type="range" id="amplification" min="1" max="100" value="100">
      </div>  
      <div class="slider-container">
        <label for="basstreble">Bass & Treble</label>
        <input type="range" id="basstreble" min="1" max="100" value="1">
      </div>
      <div class="slider-container">
        <label for="static">Static</label>
        <input type="range" id="static" min="0" max="100" value="0">
      </div>
      <div class="slider-container">
        <label for="reverb">Reverb</label>
        <input type="range" id="reverb" min="0" max="100" value="0">
      </div>
      <div class="slider-container">
        <button id="audioReverse">Reverse Audio</button>
      </div>
    </div>

    <div id="downloadOptions">
      <h2 class="section-title">Download Options</h2>
      <div class="controls">
        <button id="recordButton">Record Media</button>
        <button id="downloadSourceButton">Download Source</button>
      </div>
    </div>

    <!-- Download Source Modal -->
    <div id="downloadModal">
      <div class="modal-content">
        <h2>Video Source</h2>
        <video id="sourceVideo" controls controlsList="download"></video>
        <div class="download-controls">
          <button id="closeSourceModal">Close</button>
        </div>
      </div>
    </div>

  </div>

<script>
let audioContext = null;
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const videoInput = document.getElementById('videoInput');
let video = null;
let source;
let distortionNode;
let analyzer;
let gainNode;
let bassTrebleNode;
let trebleNode;
let staticNode;
let reverbNode;
let activeEffects = new Set();
let isProcessing = false;
let offscreenCanvas = document.createElement('canvas');
let offscreenCtx = offscreenCanvas.getContext('2d');
let rowShiftAmount = 0;
let displayShiftAmount = 0;
let lastFrameTime = 0;
const targetFPS = 30;
const frameInterval = 1000 / targetFPS;
let frameBuffer = [];
const FRAME_BUFFER_SIZE = 30;
let currentNoise = null;
let lastFrameBuffer = null;
let frameSkipCounter = 0;
let lagIntensity = 0;
let previousFrame = null;
let motionTrailFrames = [];
const TRAIL_LENGTH = 5;

let isReversed = false;
let originalVideo = null;
let reversedVideo = null;
let audioReversed = false;
let audioBuffer = null;

let staticAmount = 0;

function initAudio() {
  distortionNode = audioContext.createWaveShaper();
  analyzer = audioContext.createAnalyser();
  gainNode = audioContext.createGain();
  bassTrebleNode = audioContext.createBiquadFilter();
  trebleNode = audioContext.createBiquadFilter();
  staticNode = audioContext.createGain();
  
  // Create reverb node
  reverbNode = audioContext.createConvolver();
  createReverb().then(buffer => {
    reverbNode.buffer = buffer;
  });
  
  // Set up audio routing
  source.connect(distortionNode);
  distortionNode.connect(staticNode);
  staticNode.connect(reverbNode);
  reverbNode.connect(bassTrebleNode);
  staticNode.connect(bassTrebleNode);
  bassTrebleNode.connect(trebleNode);
  trebleNode.connect(gainNode);
  gainNode.connect(analyzer);
  analyzer.connect(audioContext.destination);
  
  bassTrebleNode.type = 'lowshelf';
  bassTrebleNode.frequency.value = 100;
  trebleNode.type = 'highshelf';
  trebleNode.frequency.value = 10000;
  gainNode.gain.value = 1;
  bassTrebleNode.gain.value = 0;
  trebleNode.gain.value = 0;
}

// Add new function to create reverb impulse response
async function createReverb() {
  const length = 2;
  const decay = 2.0;
  const sampleRate = audioContext.sampleRate;
  const bufferLength = length * sampleRate;
  const buffer = audioContext.createBuffer(2, bufferLength, sampleRate);
  
  for (let channel = 0; channel < 2; channel++) {
    const channelData = buffer.getChannelData(channel);
    for (let i = 0; i < bufferLength; i++) {
      const t = i / sampleRate;
      channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - t / length, decay);
    }
  }
  
  return buffer;
}

videoInput.addEventListener('change', function (e) {
  const file = e.target.files[0];
  if (file) {
    frameBuffer = [];
    if (video) {
      video.pause();
      video.currentTime = 0;
      video.src = '';
      if (source) {
        source.disconnect();
        source = null;
      }
      URL.revokeObjectURL(video.src);
    }
    if (currentNoise) {
      currentNoise.stop();
      currentNoise = null;
    }
    document.getElementById('static').value = 0;
    lastFrameBuffer = null;
    frameSkipCounter = 0;
    lagIntensity = 0;
    document.querySelectorAll('.controls button').forEach(button => {
      button.classList.remove('active');
    });
    videoContainer.className = '';
    videoContainer.classList.add('video-container');
    video = document.createElement('video');
    video.src = URL.createObjectURL(file);
    video.loop = true;
    video.muted = false;
    video.controls = true;
    video.controlsList = "download";
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    } else if (audioContext.state === 'suspended') {
      audioContext.resume();
    }
    video.addEventListener('loadedmetadata', () => {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      offscreenCanvas.width = video.videoWidth;
      offscreenCanvas.height = video.videoHeight;
      source = audioContext.createMediaElementSource(video);
      initAudio();
      video.play().catch(function (error) {
        console.log("Video play failed:", error);
      });
      requestAnimationFrame(processFrame);
    });
  }
});

function processFrame(timestamp) {
  if (timestamp - lastFrameTime < frameInterval) {
    requestAnimationFrame(processFrame);
    return;
  }
  lastFrameTime = timestamp;
  if (video && video.readyState === 4) {
    const scaleFactor = 0.75;
    const scaledWidth = canvas.width * scaleFactor;
    const scaledHeight = canvas.height * scaleFactor;
    offscreenCanvas.width = scaledWidth;
    offscreenCanvas.height = scaledHeight;
    offscreenCtx.drawImage(video, 0, 0, scaledWidth, scaledHeight);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(offscreenCanvas, 0, 0, canvas.width, canvas.height);
    
    // Store frame in buffer regardless of effects
    if (frameBuffer.length >= FRAME_BUFFER_SIZE) {
      frameBuffer.shift();
    }
    const frameData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    frameBuffer.push(frameData);

    // Always get fresh image data for effects
    let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const width = canvas.width;
    const height = canvas.height;
    const tempData = new Uint8ClampedArray(data);

    let shouldApplyEffects = activeEffects.size > 0 || 
                            rowShiftAmount !== 0 || 
                            displayShiftAmount !== 0 || 
                            document.getElementById('brightness').value != 0;

    if (shouldApplyEffects) {
      // Apply base transformations (row shift and display shift)
      if (rowShiftAmount !== 0 || displayShiftAmount !== 0) {
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const idx = (y * width + x) * 4;
            let sourceX = x;

            if (rowShiftAmount !== 0) {
              const rowPosition = 1 - y / height;
              const shift = Math.round(rowShiftAmount / 100 * width * rowPosition);
              sourceX = (sourceX + width + shift) % width;
            }

            if (displayShiftAmount !== 0) {
              const shift = Math.round(displayShiftAmount / 100 * width);
              sourceX = (sourceX + width + shift) % width;
            }

            const sourceIdx = (y * width + sourceX) * 4;
            data[idx] = tempData[sourceIdx];
            data[idx + 1] = tempData[sourceIdx + 1];
            data[idx + 2] = tempData[sourceIdx + 2];
            data[idx + 3] = tempData[sourceIdx + 3];
          }
        }
      }

      // Apply all active effects in sequence
      if (activeEffects.has('pixelate')) applyPixelate(imageData);
      if (activeEffects.has('videoCrush')) applyVideoCrush(imageData);
      if (activeEffects.has('shuffle')) applyPixelShuffle(imageData);
      if (activeEffects.has('rgbSplit')) applyRGBSplit(imageData);
      if (activeEffects.has('noise')) applyNoise(imageData);
      if (activeEffects.has('scanlines')) applyScanlines(imageData);
      if (activeEffects.has('rainbow')) applyRainbow(imageData);
      if (activeEffects.has('frameRandomizer')) applyFrameRandomizer(imageData);
      if (activeEffects.has('lag')) applyLagEffect(imageData);
      if (activeEffects.has('invert')) applyInvert(imageData);
      if (activeEffects.has('desaturate')) applyDesaturate(imageData);
      if (activeEffects.has('contrast')) applyContrast(imageData);
      if (activeEffects.has('motionTrail')) applyMotionTrail(imageData);
      if (activeEffects.has('redTint')) applyRedTint(imageData);
      if (activeEffects.has('videoStatic')) applyVideoStatic(imageData);
      if (activeEffects.has('signalCorruption')) applySignalCorruption(imageData);
      if (activeEffects.has('dataMosh')) applyDataMosh(imageData);
      if (activeEffects.has('blocksGlitch')) applyBlocksGlitch(imageData);
      if (activeEffects.has('tearingEffect')) applyTearingEffect(imageData);
      if (activeEffects.has('colorShift')) applyColorShift(imageData);
      if (activeEffects.has('ghosting')) applyGhosting(imageData);
      if (activeEffects.has('chromaticAberration')) applyChromaticAberration(imageData);
      if (activeEffects.has('waveform')) applyWaveformDistortion(imageData);
      if (activeEffects.has('mirrorGlitch')) applyMirrorGlitch(imageData);
      if (activeEffects.has('timeDisplacement')) applyTimeDisplacement(imageData);
      if (activeEffects.has('pixelSort')) applyPixelSort(imageData);
      if (activeEffects.has('compressionArtifacts')) applyCompressionArtifacts(imageData);
      if (activeEffects.has('glitchWalk')) applyGlitchWalk(imageData);
      if (activeEffects.has('interlace')) applyInterlace(imageData);
      if (activeEffects.has('phosphor')) applyPhosphorBurn(imageData);
      if (activeEffects.has('analogDrift')) applyAnalogDrift(imageData);
      if (activeEffects.has('vhsTracking')) applyVHSTracking(imageData);
      if (activeEffects.has('digitalTear')) applyDigitalTear(imageData);
      if (activeEffects.has('acidWash')) applyAcidWash(imageData);
      if (activeEffects.has('plasmaWave')) applyPlasmaWave(imageData);
      if (activeEffects.has('bitrot')) applyBitrot(imageData);
      if (activeEffects.has('frequencyShift')) applyFrequencyShift(imageData);
      if (activeEffects.has('analogBleed')) applyAnalogBleed(imageData);
      if (activeEffects.has('timeStretch')) applyTimeStretch(imageData);
      if (activeEffects.has('digitalSmear')) applyDigitalSmear(imageData);
      if (activeEffects.has('quantumGlitch')) applyQuantumGlitch(imageData);
      if (activeEffects.has('fractalNoise')) applyFractalNoise(imageData);
      if (activeEffects.has('signalBleed')) applySignalBleed(imageData);
      if (activeEffects.has('memoryLeak')) applyMemoryLeak(imageData);
      if (activeEffects.has('mathGlitch')) applyMathGlitch(imageData);
      if (activeEffects.has('cellularAutomata')) applyCellularAutomata(imageData);
      if (activeEffects.has('edgeDetection')) applyEdgeDetection(imageData);
      if (activeEffects.has('kaleidoscope')) applyKaleidoscope(imageData);
      if (activeEffects.has('oilPainting')) applyOilPainting(imageData);
      if (activeEffects.has('pixelBleed')) applyPixelBleed(imageData);
      if (activeEffects.has('magneticField')) applyMagneticField(imageData);
      if (activeEffects.has('energySpiral')) applyEnergySpiral(imageData);
      if (activeEffects.has('quantumFlux')) applyQuantumFlux(imageData);
      if (activeEffects.has('neonGlow')) applyNeonGlow(imageData);
      if (activeEffects.has('liquidMetal')) applyLiquidMetal(imageData);
      if (activeEffects.has('neuralGlitch')) applyNeuralGlitch(imageData);
      if (activeEffects.has('voronoiBreak')) applyVoronoiBreak(imageData);
      if (activeEffects.has('electricNoise')) applyElectricNoise(imageData);
      if (activeEffects.has('subatomicShuffle')) applySubatomicShuffle(imageData);
      if (activeEffects.has('rgbToYuv')) applyRgbToYuv(imageData);
      if (activeEffects.has('yuvToRgb')) applyYuvToRgb(imageData);
      if (activeEffects.has('cumulativeMath')) applyCumulativeMath(imageData);
      if (activeEffects.has('literalSort')) applyLiteralSort(imageData);
      if (activeEffects.has('lowPass')) applyLowPass(imageData);
      if (activeEffects.has('lumiSort')) applyLumiSort(imageData);
      if (activeEffects.has('qamFault')) applyQamFault(imageData);
      if (activeEffects.has('threeDDisplace')) applyThreeDDisplace(imageData);
      if (activeEffects.has('codeBlock')) applyCodeBlock(imageData);
      if (activeEffects.has('tvNoise')) applyTvNoise(imageData);
      if (activeEffects.has('vhsTape')) applyVhsTape(imageData);
      if (activeEffects.has('dataCorruption')) applyDataCorruption(imageData);
      if (activeEffects.has('signalJammer')) applySignalJammer(imageData);
      if (activeEffects.has('crtEffect')) applyCrtEffect(imageData);
      if (activeEffects.has('filmGrain')) applyFilmGrain(imageData);
      if (activeEffects.has('oldMovie')) applyOldMovie(imageData);
      if (activeEffects.has('fractalize')) applyFractalize(imageData);
      if (activeEffects.has('bloomEffect')) applyBloomEffect(imageData);
      if (activeEffects.has('deepfry')) applyDeepfry(imageData);
      if (activeEffects.has('infrared')) applyInfrared(imageData);
      if (activeEffects.has('nightVision')) applyNightVision(imageData);
      if (activeEffects.has('thermographics')) applyThermographics(imageData);
      if (activeEffects.has('radioWaves')) applyRadioWaves(imageData);
      if (activeEffects.has('xray')) applyXray(imageData);
      if (activeEffects.has('vaporwave')) applyVaporwave(imageData);
      if (activeEffects.has('cyberpunk')) applyCyberpunk(imageData);
      if (activeEffects.has('glitchCore')) applyGlitchCore(imageData);
      if (activeEffects.has('recursion')) applyRecursion(imageData);
      if (activeEffects.has('pixelation3D')) applyPixelation3D(imageData);
      if (activeEffects.has('timeWarp')) applyTimeWarp(imageData);
      if (activeEffects.has('fourthDimension')) applyFourthDimension(imageData);
      if (activeEffects.has('dataBending')) applyDataBending(imageData);
      if (activeEffects.has('circuitBreak')) applyCircuitBreak(imageData);
      if (activeEffects.has('machineCode')) applyMachineCode(imageData);
      if (activeEffects.has('artifactGeneration')) applyArtifactGeneration(imageData);
      if (activeEffects.has('quantumEntanglement')) applyQuantumEntanglement(imageData);
      if (activeEffects.has('matrixRain')) applyMatrixRain(imageData);
      if (activeEffects.has('hologramGlitch')) applyHologramGlitch(imageData);
      if (activeEffects.has('sinWave')) applySinWave(imageData);
      if (activeEffects.has('cosWave')) applyCosWave(imageData);
      if (activeEffects.has('tanWave')) applyTanWave(imageData);
      if (activeEffects.has('byteShift')) applyByteShift(imageData);
      if (activeEffects.has('harmonicDistortion')) applyHarmonicDistortion(imageData);
      if (activeEffects.has('cellularShift')) applyCellularShift(imageData);
      if (activeEffects.has('digitalDecay')) applyDigitalDecay(imageData);
      if (activeEffects.has('fractalMosaic')) applyFractalMosaic(imageData);

      // Always apply brightness last
      applyBrightness(imageData);

      // Put the modified image data back to the canvas
      ctx.putImageData(imageData, 0, 0);
    }
  }
  requestAnimationFrame(processFrame);
}

function applyRGBSplit(imageData) {
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    data[i] = data[i + 4] || data[i];
    data[i + 2] = data[i - 4] || data[i + 2];
  }
}

function applyNoise(imageData) {
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 8) {
    const noise = Math.random() * 50;
    data[i] = data[i] + noise;
    data[i + 1] = data[i + 1] + noise;
    data[i + 2] = data[i + 2] + noise;
  }
}

function applyScanlines(imageData) {
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const y = Math.floor(i / 4 / canvas.width);
    if (y % 2 === 0) {
      data[i] *= 0.5;
      data[i + 1] *= 0.5;
      data[i + 2] *= 0.5;
    }
  }
}

function applyPixelate(imageData) {
  const pixelSize = 8;
  const width = canvas.width;
  const height = canvas.height;
  const data = imageData.data;
  for (let y = 0; y < height; y += pixelSize) {
    for (let x = 0; x < width; x += pixelSize) {
      const idx = (y * width + x) * 4;
      const r = data[idx];
      const g = data[idx + 1];
      const b = data[idx + 2];
      for (let py = y; py < Math.min(y + pixelSize, height); py++) {
        for (let px = x; px < Math.min(x + pixelSize, width); px++) {
          const pidx = (py * width + px) * 4;
          data[pidx] = r;
          data[pidx + 1] = g;
          data[pidx + 2] = b;
        }
      }
    }
  }
}

function applyVideoCrush(imageData) {
  const data = imageData.data;
  const width = canvas.width;
  const height = canvas.height;
  const crushAmount = 0.8;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      if (Math.random() < crushAmount) {
        const shiftX = Math.floor(Math.random() * 10) - 5;
        const shiftY = Math.floor(Math.random() * 10) - 5;
        const sourceIdx = (Math.min(Math.max(y + shiftY, 0), height - 1) * width + Math.min(Math.max(x + shiftX, 0), width - 1)) * 4;
        data[idx] = data[sourceIdx];
        data[idx + 1] = data[sourceIdx + 1];
        data[idx + 2] = data[sourceIdx + 2];
        if (Math.random() < 0.5) {
          data[idx] = Math.floor(data[idx] / 32) * 32;
          data[idx + 1] = Math.floor(data[idx + 1] / 32) * 32;
          data[idx + 2] = Math.floor(data[idx + 2] / 32) * 32;
        }
      }
    }
  }
}

function applyPixelShuffle(imageData) {
  const data = imageData.data;
  const width = canvas.width;
  const height = canvas.height;
  const blockSize = 8;
  const blocks = [];
  for (let y = 0; y < height; y += blockSize) {
    for (let x = 0; x < width; x += blockSize) {
      blocks.push({
        x,
        y
      });
    }
  }
  for (let i = blocks.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const temp = blocks[i];
    blocks[i] = blocks[j];
    blocks[j] = temp;
  }
  const tempData = new Uint8ClampedArray(data);
  blocks.forEach((block, i) => {
    const targetBlock = blocks[(i + 1) % blocks.length];
    for (let y = 0; y < blockSize && block.y + y < height; y++) {
      for (let x = 0; x < blockSize && block.x + x < width; x++) {
        const sourceIdx = ((block.y + y) * width + block.x + x) * 4;
        const targetIdx = ((targetBlock.y + y) * width + targetBlock.x + x) * 4;
        
        data[targetIdx] = tempData[sourceIdx];
        data[targetIdx + 1] = tempData[sourceIdx + 1];
        data[targetIdx + 2] = tempData[sourceIdx + 2];
        data[targetIdx + 3] = tempData[sourceIdx + 3];
      }
    }
  });
}

function applyRainbow(imageData) {
  const data = imageData.data;
  const width = canvas.width;
  const height = canvas.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      const hue = (x / width * 360 + time * 50) % 360;
      const [r, g, b] = hslToRgb(hue / 360, 0.5, 0.5);
      data[idx] = (data[idx] + r) / 2;
      data[idx + 1] = (data[idx + 1] + g) / 2;
      data[idx + 2] = (data[idx + 2] + b) / 2;
    }
  }
}

function applyInvert(imageData) {
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    data[i] = 255 - data[i];
    data[i + 1] = 255 - data[i + 1];
    data[i + 2] = 255 - data[i + 2];
  }
}

function hslToRgb(h, s, l) {
  let r, g, b;
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function applyDesaturate(imageData) {
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
    data[i] = avg;
    data[i + 1] = avg;
    data[i + 2] = avg;
  }
}

function applyContrast(imageData) {
  const data = imageData.data;
  const factor = 2.5;
  const intercept = 128 * (1 - factor);
  for (let i = 0; i < data.length; i += 4) {
    data[i] = factor * data[i] + intercept;
    data[i + 1] = factor * data[i + 1] + intercept;
    data[i + 2] = factor * data[i + 2] + intercept;
  }
}

function applyRowShift(imageData) {
  const data = imageData.data;
  const width = canvas.width;
  const height = canvas.height;
  const tempData = new Uint8ClampedArray(data);
  for (let y = 0; y < height; y++) {
    const rowPosition = 1 - y / height;
    const shift = Math.round(rowShiftAmount / 100 * width * rowPosition);
    for (let x = 0; x < width; x++) {
      const sourceX = (x + shift + width) % width;
      const idx = (y * width + x) * 4;
      const sourceIdx = (y * width + sourceX) * 4;
      
      data[idx] = tempData[sourceIdx];
      data[idx + 1] = tempData[sourceIdx + 1];
      data[idx + 2] = tempData[sourceIdx + 2];
      data[idx + 3] = tempData[sourceIdx + 3];
    }
  }
}

function applyDisplayShift(imageData) {
  const data = imageData.data;
  const width = canvas.width;
  const height = canvas.height;
  const tempData = new Uint8ClampedArray(data);
  const shift = Math.round(displayShiftAmount / 100 * width);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const sourceX = (x + shift + width) % width;
      const idx = (y * width + x) * 4;
      const sourceIdx = (y * width + sourceX) * 4;
      
      data[idx] = tempData[sourceIdx];
      data[idx + 1] = tempData[sourceIdx + 1];
      data[idx + 2] = tempData[sourceIdx + 2];
      data[idx + 3] = tempData[sourceIdx + 3];
    }
  }
}

function applyFrameRandomizer(imageData) {
  if (frameBuffer.length === 0) return;
  
  const data = imageData.data;
  const width = canvas.width;
  const height = canvas.height;
  
  // Create time slices
  const slices = 10;
  const sliceHeight = height / slices;
  
  for (let i = 0; i < slices; i++) {
    const frameIndex = Math.floor(Math.random() * frameBuffer.length);
    const pastFrame = frameBuffer[frameIndex];
    
    const startY = Math.floor(i * sliceHeight);
    const endY = Math.floor((i + 1) * sliceHeight);
    
    for (let y = startY; y < endY; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        if (Math.random() < 0.3) { 
          data[idx] = pastFrame.data[idx];
          data[idx + 1] = pastFrame.data[idx + 1];
          data[idx + 2] = pastFrame.data[idx + 2];
        }
      }
    }
  }
}

function applyLagEffect(imageData) {
  frameSkipCounter++;
  if (!lastFrameBuffer) {
    lastFrameBuffer = new Uint8ClampedArray(imageData.data);
  }
  if (Math.random() < 0.1) {
    lagIntensity = Math.floor(Math.random() * 20) + 5;
  }
  if (lagIntensity > 0) {
    imageData.data.set(lastFrameBuffer);
    lagIntensity--;
  } else {
    lastFrameBuffer.set(imageData.data);
  }
  if (frameSkipCounter % 30 === 0 && Math.random() < 0.3) {
    imageData.data.set(lastFrameBuffer);
  }
}

function applyMotionTrail(imageData) {
  if (!previousFrame) {
    previousFrame = new ImageData(
      new Uint8ClampedArray(imageData.data),
      imageData.width,
      imageData.height
    );
    return;
  }

  // Add current frame to trail buffer
  motionTrailFrames.unshift(new ImageData(
    new Uint8ClampedArray(imageData.data),
    imageData.width,
    imageData.height
  ));

  // Keep only TRAIL_LENGTH frames
  if (motionTrailFrames.length > TRAIL_LENGTH) {
    motionTrailFrames.pop();
  }

  // Blend all frames with decreasing opacity
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;

  for (let i = 0; i < motionTrailFrames.length; i++) {
    const trailFrame = motionTrailFrames[i];
    const opacity = 1 - (i / TRAIL_LENGTH);

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        const diff = Math.abs(data[idx] - trailFrame.data[idx]) +
                    Math.abs(data[idx + 1] - trailFrame.data[idx + 1]) +
                    Math.abs(data[idx + 2] - trailFrame.data[idx + 2]);

        // Only blend pixels that have significant movement
        if (diff > 30) {
          data[idx] = data[idx] * (1 - opacity) + trailFrame.data[idx] * opacity;
          data[idx + 1] = data[idx + 1] * (1 - opacity) + trailFrame.data[idx + 1] * opacity;
          data[idx + 2] = data[idx + 2] * (1 - opacity) + trailFrame.data[idx + 2] * opacity;
        }
      }
    }
  }

  previousFrame = new ImageData(
    new Uint8ClampedArray(imageData.data),
    imageData.width,
    imageData.height
  );
}

function toggleEffect(effectName, button) {
  if (activeEffects.has(effectName)) {
    activeEffects.delete(effectName);
    button.classList.remove('active');
  } else {
    activeEffects.add(effectName);
    button.classList.add('active');
  }
}

function generateStaticNoise(amount) {
  const bufferSize = audioContext.sampleRate;
  const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * (amount / 100);
  }
  const noiseSource = audioContext.createBufferSource();
  noiseSource.buffer = buffer;
  noiseSource.loop = true;
  noiseSource.connect(staticNode);
  noiseSource.start();
  return noiseSource;
}

document.getElementById('distortion').addEventListener('input', e => {
  const amount = parseInt(e.target.value);
  distortionNode.curve = makeDistortionCurve(amount);
});

document.getElementById('amplification').value = 100;
document.getElementById('amplification').addEventListener('input', e => {
  const amount = parseInt(e.target.value);
  gainNode.gain.value = amount / 100 * 2;
});

document.getElementById('basstreble').addEventListener('input', e => {
  const amount = parseInt(e.target.value);
  const boost = amount / 100 * 30 - 15;
  bassTrebleNode.gain.value = boost;
  trebleNode.gain.value = boost;
});

document.getElementById('shuffle').addEventListener('click', e => toggleEffect('shuffle', e.target));
document.getElementById('rgbSplit').addEventListener('click', e => toggleEffect('rgbSplit', e.target));
document.getElementById('noise').addEventListener('click', e => toggleEffect('noise', e.target));
document.getElementById('scanlines').addEventListener('click', e => toggleEffect('scanlines', e.target));
document.getElementById('pixelate').addEventListener('click', e => toggleEffect('pixelate', e.target));
document.getElementById('videoCrush').addEventListener('click', e => toggleEffect('videoCrush', e.target));
document.getElementById('rainbow').addEventListener('click', e => toggleEffect('rainbow', e.target));
document.getElementById('invert').addEventListener('click', e => toggleEffect('invert', e.target));
document.getElementById('desaturate').addEventListener('click', e => toggleEffect('desaturate', e.target));
document.getElementById('contrast').addEventListener('click', e => toggleEffect('contrast', e.target));
document.getElementById('rowShift').addEventListener('input', e => {
  rowShiftAmount = parseInt(e.target.value);
});
document.getElementById('displayShift').addEventListener('input', e => {
  displayShiftAmount = parseInt(e.target.value);
});
document.getElementById('frameRandomizer').addEventListener('click', e => toggleEffect('frameRandomizer', e.target));
document.getElementById('static').addEventListener('input', e => {
  const amount = parseInt(e.target.value);
  if (currentNoise) {
    currentNoise.stop();
    currentNoise = null;
  }
  if (amount > 0) {
    currentNoise = generateStaticNoise(amount);
  }
});
document.getElementById('lag').addEventListener('click', e => toggleEffect('lag', e.target));
document.getElementById('motionTrail').addEventListener('click', e => toggleEffect('motionTrail', e.target));
document.getElementById('redTint').addEventListener('click', e => toggleEffect('redTint', e.target));

function applyRedTint(imageData) {
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    data[i] = Math.min(255, data[i] * 1.5);      // Red channel
    data[i + 1] *= 0.5;                          // Green channel
    data[i + 2] *= 0.5;                          // Blue channel
  }
}

document.getElementById('videoStatic').addEventListener('click', e => toggleEffect('videoStatic', e.target));
document.getElementById('staticAmount').addEventListener('input', e => {
  staticAmount = parseInt(e.target.value);
});

function applySignalCorruption(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  for (let i = 0; i < 10; i++) {
    const blockHeight = Math.random() * 50;
    const startY = Math.floor(Math.random() * height);
    const shift = Math.floor(Math.random() * 100) - 50;
    
    for (let y = startY; y < Math.min(startY + blockHeight, height); y++) {
      for (let x = 0; x < width; x++) {
        const sourceX = (x + shift + width) % width;
        const idx = (y * width + x) * 4;
        const sourceIdx = (y * width + sourceX) * 4;
        
        data[idx] = data[sourceIdx] * (Math.random() * 0.5 + 0.5);
        data[idx + 1] = data[sourceIdx + 1] * (Math.random() * 0.5 + 0.5);
        data[idx + 2] = data[sourceIdx + 2] * (Math.random() * 0.5 + 0.5);
      }
    }
  }
}

function applyDataMosh(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  for (let i = 0; i < 5; i++) {
    const blockSize = Math.random() * 50 + 20;
    const x = Math.floor(Math.random() * (width - blockSize));
    const y = Math.floor(Math.random() * (height - blockSize));
    const offsetX = Math.floor(Math.random() * 100) - 50;
    const offsetY = Math.floor(Math.random() * 100) - 50;
    
    for (let by = 0; by < blockSize && y + by < height; by++) {
      for (let bx = 0; bx < blockSize && x + bx < width; bx++) {
        const sourceX = Math.min(Math.max(x + bx + offsetX, 0), width - 1);
        const sourceY = Math.min(Math.max(y + by + offsetY, 0), height - 1);
        const targetX = x + bx;
        const targetY = y + by;
        
        if (targetX < width && targetY < height) {
          const sourceIdx = (sourceY * width + sourceX) * 4;
          const targetIdx = (targetY * width + targetX) * 4;
          data[targetIdx] = data[sourceIdx];
          data[targetIdx + 1] = data[sourceIdx + 1];
          data[targetIdx + 2] = data[sourceIdx + 2];
        }
      }
    }
  }
}

function applyBlocksGlitch(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  const blockSize = 20;
  const numBlocks = 10;
  
  for (let i = 0; i < numBlocks; i++) {
    const x = Math.floor(Math.random() * (width - blockSize));
    const y = Math.floor(Math.random() * (height - blockSize));
    
    const shiftX = Math.floor(Math.random() * 50) - 25;
    const shiftY = Math.floor(Math.random() * 50) - 25;
    
    for (let by = 0; by < blockSize && y + by < height; by++) {
      for (let bx = 0; bx < blockSize && x + bx < width; bx++) {
        const sourceX = x + bx;
        const sourceY = y + by;
        const targetX = Math.min(Math.max(x + bx + shiftX, 0), width - 1);
        const targetY = Math.min(Math.max(y + by + shiftY, 0), height - 1);
        
        const sourceIdx = (sourceY * width + sourceX) * 4;
        const targetIdx = (targetY * width + targetX) * 4;
        
        data[targetIdx] = data[sourceIdx] * (Math.random() * 0.5 + 0.5);
        data[targetIdx + 1] = data[sourceIdx + 1] * (Math.random() * 0.5 + 0.5);
        data[targetIdx + 2] = data[sourceIdx + 2] * (Math.random() * 0.5 + 0.5);
      }
    }
  }
}

function applyTearingEffect(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  const numTears = Math.floor(Math.random() * 5) + 3;
  const tearHeight = Math.floor(height / numTears);
  
  for (let i = 0; i < numTears; i++) {
    const y = Math.floor(Math.random() * (height - tearHeight));
    const shift = Math.floor(Math.random() * width * 0.3) * (Math.random() < 0.5 ? 1 : -1);
    
    for (let ty = y; ty < y + tearHeight; ty++) {
      for (let x = 0; x < width; x++) {
        const sourceX = (x + shift + width) % width;
        const idx = (ty * width + x) * 4;
        const sourceIdx = (ty * width + sourceX) * 4;
        
        data[idx] = data[sourceIdx];
        data[idx + 1] = data[sourceIdx + 1];
        data[idx + 2] = data[sourceIdx + 2];
      }
    }
  }
}

function applyColorShift(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  const rShift = Math.floor(Math.random() * 50) - 25;
  const gShift = Math.floor(Math.random() * 50) - 25;
  const bShift = Math.floor(Math.random() * 50) - 25;
  
  const tempData = new Uint8ClampedArray(data);
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      const rIdx = ((y + rShift + height) % height * width + (x + rShift + width) % width) * 4;
      const gIdx = ((y + gShift + height) % height * width + (x + gShift + width) % width) * 4;
      const bIdx = ((y + bShift + height) % height * width + (x + bShift + width) % width) * 4;
      
      data[idx] = tempData[rIdx];
      data[idx + 1] = tempData[gIdx + 1];
      data[idx + 2] = tempData[bIdx + 2];
    }
  }
}

function applyGhosting(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  const numGhosts = 3;
  const ghostOpacity = 0.3;
  
  const tempData = new Uint8ClampedArray(data);
  
  for (let i = 1; i <= numGhosts; i++) {
    const offsetX = Math.floor(Math.random() * 20) - 10;
    const offsetY = Math.floor(Math.random() * 20) - 10;
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const targetX = Math.min(Math.max(x + offsetX * i, 0), width - 1);
        const targetY = Math.min(Math.max(y + offsetY * i, 0), height - 1);
        
        const idx = (y * width + x) * 4;
        const targetIdx = (targetY * width + targetX) * 4;
        
        data[idx] = data[idx] * (1 - ghostOpacity) + tempData[targetIdx] * ghostOpacity;
        data[idx + 1] = data[idx + 1] * (1 - ghostOpacity) + tempData[targetIdx + 1] * ghostOpacity;
        data[idx + 2] = data[idx + 2] * (1 - ghostOpacity) + tempData[targetIdx + 2] * ghostOpacity;
      }
    }
  }
}

function applyChromaticAberration(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  
  const rOffset = 5;
  const bOffset = -5;
  
  const tempData = new Uint8ClampedArray(data);
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      const rIdx = (y * width + Math.min(Math.max(x + rOffset, 0), width - 1)) * 4;
      const bIdx = (y * width + Math.min(Math.max(x + bOffset, 0), width - 1)) * 4;
      
      data[idx] = tempData[rIdx];     // Red channel
      data[idx + 1] = tempData[idx + 1]; // Green channel (unchanged)
      data[idx + 2] = tempData[bIdx + 2]; // Blue channel
    }
  }
}

function applyWaveformDistortion(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    const wave = Math.sin(y * 0.1 + time) * 20;
    for (let x = 0; x < width; x++) {
      const sourceX = Math.floor(x + wave) % width;
      const idx = (y * width + x) * 4;
      const sourceIdx = (y * width + sourceX) * 4;
      
      data[idx] = data[sourceIdx];
      data[idx + 1] = data[sourceIdx + 1];
      data[idx + 2] = data[sourceIdx + 2];
    }
  }
}

function applyMirrorGlitch(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  const mirrorPoints = Math.floor(Math.random() * 3) + 2;
  
  for (let i = 0; i < mirrorPoints; i++) {
    const mirrorY = Math.floor(Math.random() * height);
    const direction = Math.random() < 0.5 ? 1 : -1;
    
    for (let y = 0; y < height/4; y++) {
      const sourceY = (mirrorY + y * direction + height) % height;
      const targetY = (mirrorY - y * direction + height) % height;
      
      for (let x = 0; x < width; x++) {
        const sourceIdx = (sourceY * width + x) * 4;
        const targetIdx = (targetY * width + x) * 4;
        
        if (Math.random() < 0.8) { 
          data[targetIdx] = data[sourceIdx];
          data[targetIdx + 1] = data[sourceIdx + 1];
          data[targetIdx + 2] = data[sourceIdx + 2];
        }
      }
    }
  }
}

function applyTimeDisplacement(imageData) {
  if (frameBuffer.length < 2) return;
  
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    const frameOffset = Math.floor(Math.random() * frameBuffer.length);
    const pastFrame = frameBuffer[(frameBuffer.length + frameOffset) % frameBuffer.length];
    
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      if (Math.random() < 0.5) {
        data[idx] = pastFrame.data[idx];
        data[idx + 1] = pastFrame.data[idx + 1];
        data[idx + 2] = pastFrame.data[idx + 2];
      }
    }
  }
}

function applyPixelSort(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  const numSegments = Math.floor(Math.random() * 5) + 3;
  
  for (let i = 0; i < numSegments; i++) {
    const startY = Math.floor(Math.random() * (height - 50));
    const segmentHeight = Math.floor(Math.random() * 50) + 20;
    
    const pixels = [];
    
    for (let y = startY; y < Math.min(startY + segmentHeight, height); y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
        pixels.push({idx, brightness, color: [data[idx], data[idx + 1], data[idx + 2]]});
      }
    }
    
    pixels.sort((a, b) => a.brightness - b.brightness);
    
    pixels.forEach((pixel, index) => {
      const targetIdx = (Math.floor(index / width) + startY) * width * 4 + (index % width) * 4;
      data[targetIdx] = pixel.color[0];
      data[targetIdx + 1] = pixel.color[1];
      data[targetIdx + 2] = pixel.color[2];
    });
  }
}

function applyCompressionArtifacts(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  const blockSize = 8; 
  for (let y = 0; y < height; y += blockSize) {
    for (let x = 0; x < width; x += blockSize) {
      if (Math.random() < 0.3) { 
        let sumR = 0, sumG = 0, sumB = 0;
        
        for (let by = 0; by < blockSize && y + by < height; by++) {
          for (let bx = 0; bx < blockSize && x + bx < width; bx++) {
            const idx = ((y + by) * width + (x + bx)) * 4;
            sumR += data[idx];
            sumG += data[idx + 1];
            sumB += data[idx + 2];
          }
        }
        
        const rAvg = sumR / (blockSize * blockSize);
        const gAvg = sumG / (blockSize * blockSize);
        const bAvg = sumB / (blockSize * blockSize);
        
        for (let by = 0; by < blockSize && y + by < height; by++) {
          for (let bx = 0; bx < blockSize && x + bx < width; bx++) {
            const idx = ((y + by) * width + (x + bx)) * 4;
            data[idx] = rAvg + (Math.random() - 0.5) * 30;
            data[idx + 1] = gAvg + (Math.random() - 0.5) * 30;
            data[idx + 2] = bAvg + (Math.random() - 0.5) * 30;
          }
        }
      }
    }
  }
}

function applyGlitchWalk(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  const time = Date.now() * 0.001;
  const walkSpeed = 2;
  
  for (let y = 0; y < height; y++) {
    const offset = Math.sin(y * 0.1 + time * walkSpeed) * 20;
    const glitchProbability = Math.sin(y * 0.05 + time) * 0.5 + 0.5;
    
    for (let x = 0; x < width; x++) {
      if (Math.random() < glitchProbability * 0.1) {
        const sourceX = (x + Math.floor(offset) + width) % width;
        const idx = (y * width + x) * 4;
        const sourceIdx = (y * width + sourceX) * 4;
        
        data[idx] = data[idx] * (1 + Math.cos(sourceX * 0.01)) + data[sourceIdx] * (1 - Math.cos(sourceX * 0.01));
        data[idx + 1] = data[idx + 1] * (1 + Math.sin(sourceX * 0.01)) + data[sourceIdx + 1] * (1 - Math.sin(sourceX * 0.01));
        data[idx + 2] = data[idx + 2] * (1 + Math.tan(sourceX * 0.01)) + data[sourceIdx + 2] * (1 - Math.tan(sourceX * 0.01));
      }
    }
  }
}

function applyInterlace(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  const scanlineHeight = 2;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    if ((y + Math.floor(time * 20)) % (scanlineHeight * 2) < scanlineHeight) {
      const offset = Math.sin(y * 0.1 + time) * 10;
      
      for (let x = 0; x < width; x++) {
        const sourceX = Math.floor(x + offset + width) % width;
        const idx = (y * width + x) * 4;
        const sourceIdx = (y * width + sourceX) * 4;
        
        data[idx] = data[sourceIdx] * 1.2;
        data[idx + 1] = data[sourceIdx + 1] * 0.8;
        data[idx + 2] = data[sourceIdx + 2] * 0.8;
      }
    }
  }
}

function applyPhosphorBurn(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  if (!window.phosphorBuffer) {
    window.phosphorBuffer = new Uint8ClampedArray(data);
  }
  
  const decay = 0.95;
  for (let i = 0; i < data.length; i += 4) {
    window.phosphorBuffer[i] = Math.max(data[i], window.phosphorBuffer[i] * decay);
    window.phosphorBuffer[i + 1] = Math.max(data[i + 1], window.phosphorBuffer[i + 1] * decay);
    window.phosphorBuffer[i + 2] = Math.max(data[i + 2], window.phosphorBuffer[i + 2] * decay);
    
    data[i] = window.phosphorBuffer[i];
    data[i + 1] = window.phosphorBuffer[i + 1];
    data[i + 2] = window.phosphorBuffer[i + 2];
  }
}

function applyAnalogDrift(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    const drift = Math.sin(y * 0.1 + time) * 10;
    const wave = Math.cos(time * 2 + y * 0.1) * 5;
    
    for (let x = 0; x < width; x++) {
      const sourceX = Math.floor(x + drift + wave) % width;
      const idx = (y * width + x) * 4;
      const sourceIdx = (y * width + sourceX) * 4;
      
      data[idx] = data[sourceIdx];
      data[idx + 1] = data[sourceIdx + 1];
      data[idx + 2] = data[sourceIdx + 2];
    }
  }
}

function applyVHSTracking(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  const trackingOffset = Math.sin(time) * 20;
  
  for (let y = 0; y < height; y++) {
    if (Math.random() < 0.05) {
      const trackingHeight = Math.floor(Math.random() * 10) + 5;
      const offset = Math.random() * 20 - 10 + trackingOffset;
      
      for (let ty = y; ty < Math.min(y + trackingHeight, height); ty++) {
        for (let x = 0; x < width; x++) {
          const sourceX = (x + Math.floor(offset)) % width;
          const idx = (ty * width + x) * 4;
          const sourceIdx = (ty * width + sourceX) * 4;
          
          data[idx] = data[sourceIdx] * 0.8;
          data[idx + 1] = data[sourceIdx + 1] * 0.8;
          data[idx + 2] = data[sourceIdx + 2] * 0.8;
        }
      }
    }
  }
}

function applyDigitalTear(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  const tears = Math.floor(Math.random() * 5) + 3;
  
  for (let i = 0; i < tears; i++) {
    const y = Math.floor(Math.random() * height);
    const tearHeight = Math.floor(Math.random() * 30) + 10;
    const offset = Math.floor(Math.random() * width * 0.5);
    
    for (let ty = y; ty < Math.min(y + tearHeight, height); ty++) {
      for (let x = 0; x < width; x++) {
        const sourceX = (x + offset) % width;
        const idx = (ty * width + x) * 4;
        const sourceIdx = (ty * width + sourceX) * 4;
        
        if (Math.random() < 0.9) {
          data[idx] = data[sourceIdx];
          data[idx + 1] = data[sourceIdx + 1];
          data[idx + 2] = data[sourceIdx + 2];
        }
      }
    }
  }
}

function applyAcidWash(imageData) {
  const data = imageData.data;
  const time = Date.now() * 0.001;
  
  for (let i = 0; i < data.length; i += 4) {
    const shift = Math.sin(time + i * 0.0001) * 100;
    data[i] = data[i] * Math.sin(shift * 0.1);
    data[i + 1] = data[i + 1] * Math.cos(shift * 0.1);
    data[i + 2] = data[i + 2] * Math.tan(shift * 0.1);
  }
}

function applyPlasmaWave(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      const plasma = Math.sin(x * 0.01 + time) + Math.sin(y * 0.01 + time) +
                    Math.sin((x + y) * 0.01 + time) + Math.sin(Math.sqrt(x * x + y * y) * 0.01);
      
      data[idx] *= 0.5 + plasma * 0.5;
      data[idx + 1] *= 0.5 + plasma * 0.5;
      data[idx + 2] *= 0.5 + plasma * 0.5;
    }
  }
}

function applyBitrot(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  const corruptionPoints = Math.floor(Math.random() * 10) + 5;
  
  for (let i = 0; i < corruptionPoints; i++) {
    const x = Math.floor(Math.random() * width);
    const y = Math.floor(Math.random() * height);
    const radius = Math.floor(Math.random() * 50) + 10;
    
    for (let cy = -radius; cy < radius; cy++) {
      for (let cx = -radius; cx < radius; cx++) {
        if (cx * cx + cy * cy < radius * radius) {
          const targetX = x + cx;
          const targetY = y + cy;
          
          if (targetX >= 0 && targetX < width && targetY >= 0 && targetY < height) {
            const idx = (targetY * width + targetX) * 4;
            const bit = Math.floor(Math.random() * 8);
            data[idx] ^= (1 << bit);
            data[idx + 1] ^= (1 << bit);
            data[idx + 2] ^= (1 << bit);
          }
        }
      }
    }
  }
}

function applyFrequencyShift(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    const frequency = Math.sin(y * 0.1 + time) * 10;
    const amplitude = Math.cos(time) * 20;
    
    for (let x = 0; x < width; x++) {
      const shift = Math.sin(x * frequency * 0.01) * amplitude;
      const sourceY = Math.floor(y + shift + height) % height;
      
      const idx = (y * width + x) * 4;
      const sourceIdx = (sourceY * width + x) * 4;
      
      data[idx] = data[sourceIdx];
      data[idx + 1] = data[sourceIdx + 1];
      data[idx + 2] = data[sourceIdx + 2];
    }
  }
}

function applyAnalogBleed(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  
  for (let i = 0; i < data.length; i += 4) {
    const x = (i / 4) % width;
    const bleedAmount = Math.sin(x * 0.1) * 20;
    
    data[i] = data[i] + bleedAmount;
    data[i + 1] = Math.max(0, data[i + 1] - bleedAmount);
    data[i + 2] = data[i + 2] + bleedAmount;
  }
}

function applyTimeStretch(imageData) {
  if (frameBuffer.length < 2) return;
  
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    const frameOffset = Math.floor(Math.random() * frameBuffer.length);
    const pastFrame = frameBuffer[(frameBuffer.length + frameOffset) % frameBuffer.length];
    
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      if (Math.random() < 0.5) {
        data[idx] = pastFrame.data[idx];
        data[idx + 1] = pastFrame.data[idx + 1];
        data[idx + 2] = pastFrame.data[idx + 2];
      }
    }
  }
}

function applyDigitalSmear(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  for (let y = 0; y < height; y++) {
    if (Math.random() < 0.1) {
      let smearLength = Math.floor(Math.random() * width * 0.3);
      let smearStart = Math.floor(Math.random() * (width - smearLength));
      
      for (let x = smearStart; x < smearStart + smearLength; x++) {
        const sourceIdx = (y * width + smearStart) * 4;
        const targetIdx = (y * width + x) * 4;
        
        data[targetIdx] = data[sourceIdx];
        data[targetIdx + 1] = data[sourceIdx + 1];
        data[targetIdx + 2] = data[sourceIdx + 2];
      }
    }
  }
}

function applyQuantumGlitch(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    if (Math.random() < 0.05) {
      const quantum = Math.random() * 2 * Math.PI;
      const amplitude = Math.sin(time + quantum) * 30;
      
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        const shift = Math.sin(x * 0.01 + quantum) * amplitude;
        
        data[idx] = data[idx] * (1 + Math.cos(shift));
        data[idx + 1] = data[idx + 1] * (1 + Math.sin(shift));
        data[idx + 2] = data[idx + 2] * (1 + Math.tan(shift));
      }
    }
  }
}

function applyFractalNoise(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      const fractal = Math.sin(x * y * 0.0001 + time) * 
                     Math.cos(x * 0.01 + time) * 
                     Math.sin(y * 0.01 + time);
      
      data[idx] += fractal * 50;
      data[idx + 1] += fractal * 50;
      data[idx + 2] += fractal * 50;
    }
  }
}

function applySignalBleed(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  for (let y = 0; y < height; y++) {
    const bleedDistance = Math.random() * 20;
    const direction = Math.random() < 0.5 ? 1 : -1;
    
    for (let x = 0; x < width; x++) {
      const sourceX = (x + bleedDistance * direction + width) % width;
      const idx = (y * width + x) * 4;
      const sourceIdx = (y * width + sourceX) * 4;
      
      if (Math.random() < 0.5) {
        data[idx] = (data[idx] + data[sourceIdx]) / 2;
        data[idx + 1] = (data[idx + 1] + data[sourceIdx + 1]) / 2;
        data[idx + 2] = (data[idx + 2] + data[sourceIdx + 2]) / 2;
      }
    }
  }
}

function applyMemoryLeak(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  if (!window.memoryLeakBuffer) {
    window.memoryLeakBuffer = new Uint8ClampedArray(data);
  }
  
  for (let i = 0; i < data.length; i += 4) {
    if (Math.random() < 0.01) {
      window.memoryLeakBuffer[i] = data[i];
      window.memoryLeakBuffer[i + 1] = data[i + 1];
      window.memoryLeakBuffer[i + 2] = data[i + 2];
    }
    
    if (Math.random() < 0.1) {
      data[i] = window.memoryLeakBuffer[i];
      data[i + 1] = window.memoryLeakBuffer[i + 1];
      data[i + 2] = window.memoryLeakBuffer[i + 2];
    }
  }
}

function applyMathGlitch(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      const angle = Math.atan2(y - height/2, x - width/2);
      const dist = Math.sqrt((x - width/2) * (x - width/2) + (y - height/2) * (y - height/2));
      
      const mathEffect = Math.sin(dist * 0.05 + time) * Math.cos(angle * 3 + time);
      
      data[idx] = data[idx] * (1 + mathEffect * 0.5);
      data[idx + 1] = data[idx + 1] * (1 + mathEffect * 0.3);
      data[idx + 2] = data[idx + 2] * (1 + mathEffect * 0.7);
    }
  }
}

function applyCellularAutomata(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const tempData = new Uint8ClampedArray(data);
  
  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      const idx = (y * width + x) * 4;
      
      let count = 0;
      
      for (let ny = -1; ny <= 1; ny++) {
        for (let nx = -1; nx <= 1; nx++) {
          if (nx === 0 && ny === 0) continue;
          const nidx = ((y + ny) * width + (x + nx)) * 4;
          if (tempData[nidx] > 127) count++;
        }
      }
      
      const cell = tempData[idx] > 127;
      if (cell) {
        if (count < 2 || count > 3) {
          data[idx] = data[idx] * 0.5;
          data[idx + 1] = data[idx + 1] * 0.5;
          data[idx + 2] = data[idx + 2] * 0.5;
        }
      } else {
        if (count === 3) {
          data[idx] = data[idx] * 1.5;
          data[idx + 1] = data[idx + 1] * 1.5;
          data[idx + 2] = data[idx + 2] * 1.5;
        }
      }
    }
  }
}

function applyEdgeDetection(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const tempData = new Uint8ClampedArray(data);
  
  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      const idx = (y * width + x) * 4;
      
      const top = ((y - 1) * width + x) * 4;
      const bottom = ((y + 1) * width + x) * 4;
      const left = (y * width + (x - 1)) * 4;
      const right = (y * width + (x + 1)) * 4;
      
      const edgeH = Math.abs(tempData[left] - tempData[right]) + 
                   Math.abs(tempData[left + 1] - tempData[right + 1]) + 
                   Math.abs(tempData[left + 2] - tempData[right + 2]);
                   
      const edgeV = Math.abs(tempData[top] - tempData[bottom]) + 
                   Math.abs(tempData[top + 1] - tempData[bottom + 1]) + 
                   Math.abs(tempData[top + 2] - tempData[bottom + 2]);
      
      const edge = (edgeH + edgeV) / 6;
      
      if (edge > 30) {
        data[idx] = 255 - data[idx];
        data[idx + 1] = 255 - data[idx + 1];
        data[idx + 2] = 255 - data[idx + 2];
      }
    }
  }
}

function applyKaleidoscope(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const tempData = new Uint8ClampedArray(data);
  const centerX = width / 2;
  const centerY = height / 2;
  const segments = 8;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const dx = x - centerX;
      const dy = y - centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx);
      
      const angleShift = angle % (2 * Math.PI / segments);
      const mappedAngle = angleShift + (2 * Math.PI / segments);
      
      const newX = Math.floor(centerX + Math.cos(mappedAngle) * dist);
      const newY = Math.floor(centerY + Math.sin(mappedAngle) * dist);
      
      if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
        const sourceIdx = (newY * width + newX) * 4;
        data[idx] = tempData[sourceIdx];
        data[idx + 1] = tempData[sourceIdx + 1];
        data[idx + 2] = tempData[sourceIdx + 2];
      }
    }
  }
}

function applyOilPainting(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const tempData = new Uint8ClampedArray(data);
  const radius = 4;
  const intensity = 40;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const buckets = Array(intensity).fill().map(() => ({r: 0, g: 0, b: 0, count: 0}));
      
      for (let ky = -radius; ky <= radius; ky++) {
        for (let kx = -radius; kx <= radius; kx++) {
          const nx = x + kx;
          const ny = y + ky;
          
          if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
            const nidx = (ny * width + nx) * 4;
            const r = tempData[nidx];
            const g = tempData[nidx + 1];
            const b = tempData[nidx + 2];
            
            const bucketIdx = Math.floor((r + g + b) / (3 * 255) * intensity);
            buckets[bucketIdx].r += r;
            buckets[bucketIdx].g += g;
            buckets[bucketIdx].b += b;
            buckets[bucketIdx].count++;
          }
        }
      }
      
      const maxBucket = Math.max(...buckets.map(b => b.count));
      const maxBucketIdx = buckets.findIndex(b => b.count === maxBucket);
      
      data[idx] = buckets[maxBucketIdx].r / maxBucketIdx;
      data[idx + 1] = buckets[maxBucketIdx].g / maxBucketIdx;
      data[idx + 2] = buckets[maxBucketIdx].b / maxBucketIdx;
    }
  }
}

function applyPixelBleed(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    const bleedDirection = Math.sin(y * 0.1 + time) > 0 ? 1 : -1;
    const bleedAmount = Math.abs(Math.sin(y * 0.05 + time)) * 20;
    
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      if (Math.random() < 0.2) { 
        const sourceX = Math.min(Math.max(x + bleedDirection * bleedAmount, 0), width - 1);
        const sourceIdx = (y * width + sourceX) * 4;
        
        data[idx] = (data[idx] * 0.5 + data[sourceIdx] * 0.5);
        data[idx + 1] = (data[idx + 1] * 0.5 + data[sourceIdx + 1] * 0.5);
        data[idx + 2] = (data[idx + 2] * 0.5 + data[sourceIdx + 2] * 0.5);
      }
    }
  }
}

function applyMagneticField(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const tempData = new Uint8ClampedArray(data);
  const time = Date.now() * 0.001;
  
  const poles = [
    { x: width * 0.3, y: height * 0.3, strength: Math.sin(time) * 20 + 30 },
    { x: width * 0.7, y: height * 0.7, strength: Math.cos(time) * 20 + 30 }
  ];
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      let forceX = 0;
      let forceY = 0;
      
      for (const pole of poles) {
        const dx = x - pole.x;
        const dy = y - pole.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist > 0) {
          const force = pole.strength / dist;
          forceX += dx / dist * force;
          forceY += dy / dist * force;
        }
      }
      
      const sourceX = Math.min(Math.max(Math.floor(x + forceX), 0), width - 1);
      const sourceY = Math.min(Math.max(Math.floor(y + forceY), 0), height - 1);
      const sourceIdx = (sourceY * width + sourceX) * 4;
      
      data[idx] = tempData[sourceIdx];
      data[idx + 1] = tempData[sourceIdx + 1];
      data[idx + 2] = tempData[sourceIdx + 2];
    }
  }
}

function applyEnergySpiral(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const centerX = width / 2;
  const centerY = height / 2;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const dx = x - centerX;
      const dy = y - centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx);
      
      const spiralAngle = angle + dist * 0.05 + time;
      const spiralIntensity = Math.sin(spiralAngle) * 0.5 + 0.5;
      
      data[idx] = data[idx] * spiralIntensity + 255 * (1 - spiralIntensity);
      data[idx + 1] = data[idx + 1] * (1 - spiralIntensity) + 255 * spiralIntensity;
      data[idx + 2] = data[idx + 2] * spiralIntensity;
    }
  }
}

function applyQuantumFlux(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  const fieldFreq = 0.05;
  const fieldAmplitude = 20;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const fieldVal = Math.sin(x * fieldFreq + time) * Math.cos(y * fieldFreq + time);
      const distortionX = fieldVal * fieldAmplitude;
      const distortionY = fieldVal * fieldAmplitude;
      
      const sourceX = Math.min(Math.max(Math.floor(x + distortionX), 0), width - 1);
      const sourceY = Math.min(Math.max(Math.floor(y + distortionY), 0), height - 1);
      
      const sourceIdx = (sourceY * width + sourceX) * 4;
      
      data[idx] = (data[idx] + data[sourceIdx]) / 2;
      data[idx + 1] = (data[idx + 1] + data[sourceIdx + 1]) / 2;
      data[idx + 2] = (data[idx + 2] + data[sourceIdx + 2]) / 2;
    }
  }
}

function applyNeonGlow(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const tempData = new Uint8ClampedArray(data);
  
  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      const idx = (y * width + x) * 4;
      
      const top = ((y - 1) * width + x) * 4;
      const bottom = ((y + 1) * width + x) * 4;
      const left = (y * width + (x - 1)) * 4;
      const right = (y * width + (x + 1)) * 4;
      
      const edgeH = Math.abs(tempData[left] - tempData[right]) + 
                   Math.abs(tempData[left + 1] - tempData[right + 1]) + 
                   Math.abs(tempData[left + 2] - tempData[right + 2]);
                   
      const edgeV = Math.abs(tempData[top] - tempData[bottom]) + 
                   Math.abs(tempData[top + 1] - tempData[bottom + 1]) + 
                   Math.abs(tempData[top + 2] - tempData[bottom + 2]);
      
      const edge = (edgeH + edgeV) / 6;
      
      if (edge > 30) {
        data[idx] = 255 - data[idx];
        data[idx + 1] = 255 - data[idx + 1];
        data[idx + 2] = 255 - data[idx + 2];
      }
    }
  }
  
  for (let i = 0; i < data.length; i += 4) {
    if (data[i] > 200 && data[i + 1] > 200 && data[i + 2] > 200) {
      data[i] = 255;
      data[i + 1] = 255;
      data[i + 2] = 255;
    } else if (data[i] < 50 && data[i + 1] < 50 && data[i + 2] < 50) {
      data[i] = 0;
      data[i + 1] = 0;
      data[i + 2] = 0;
    }
  }
}

function applyLiquidMetal(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const tempData = new Uint8ClampedArray(data);
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const wave1 = Math.sin(x * 0.05 + y * 0.03 + time) * 10;
      const wave2 = Math.cos(x * 0.04 + y * 0.06 + time * 1.5) * 8;
      
      const sourceX = Math.min(Math.max(Math.floor(x + wave1), 0), width - 1);
      const sourceY = Math.min(Math.max(Math.floor(y + wave2), 0), height - 1);
      const sourceIdx = (sourceY * width + sourceX) * 4;
      
      data[idx] = Math.min(255, tempData[sourceIdx] + 50);
      data[idx + 1] = Math.min(255, tempData[sourceIdx + 1] + 50);
      data[idx + 2] = Math.min(255, tempData[sourceIdx + 2] + 50);
    }
  }
}

function applyNeuralGlitch(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const activation = 1 / (1 + Math.exp(-(Math.sin(x * 0.05 + time) + Math.cos(y * 0.05 + time))));
      
      if (activation > 0.5) {
        data[idx] = 255 - data[idx];
        data[idx + 1] = data[idx + 1];
        data[idx + 2] = 255 - data[idx + 2];
      }
      
      if (Math.abs(Math.sin(x * 0.1 + y * 0.1 + time) * Math.cos(x * 0.05 - y * 0.05 + time)) > 0.95) {
        data[idx] = 255;
        data[idx + 1] = 255;
        data[idx + 2] = 255;
      }
    }
  }
}

function applyVoronoiBreak(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const numCells = 20;
  const time = Date.now() * 0.001;
  
  const cells = [];
  for (let i = 0; i < numCells; i++) {
    cells.push({
      x: Math.random() * width,
      y: Math.random() * height,
      r: Math.sin(time + i) * 127 + 128,
      g: Math.cos(time + i) * 127 + 128,
      b: Math.sin(time * 1.5 + i) * 127 + 128
    });
  }
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      let minDist = Infinity;
      let closestCell = null;
      
      for (const cell of cells) {
        const dx = x - cell.x;
        const dy = y - cell.y;
        const dist = dx * dx + dy * dy;
        
        if (dist < minDist) {
          minDist = dist;
          closestCell = cell;
        }
      }
      
      data[idx] = (data[idx] + closestCell.r) / 2;
      data[idx + 1] = (data[idx + 1] + closestCell.g) / 2;
      data[idx + 2] = (data[idx + 2] + closestCell.b) / 2;
      
      if (Math.random() < 0.1) {
        data[idx] = 255;
        data[idx + 1] = 255;
        data[idx + 2] = 255;
      }
    }
  }
}

function applyElectricNoise(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let i = 0; i < 10; i++) {
    const startX = Math.floor(Math.random() * width);
    const startY = Math.floor(Math.random() * height);
    
    let x = startX;
    let y = startY;
    const steps = 100;
    const thickness = 2;
    
    for (let step = 0; step < steps; step++) {
      const t = step / steps;
      x = startX * (1 - t) + (Math.random() * width) * t + (Math.random() - 0.5) * 20;
      y = startY * (1 - t) + (Math.random() * height) * t + (Math.random() - 0.5) * 20;
      
      if (x >= 0 && x < width && y >= 0 && y < height) {
        const idx = (Math.floor(y) * width + Math.floor(x)) * 4;
        
        data[idx] = 220;
        data[idx + 1] = 220;
        data[idx + 2] = 255;
        
        for (let gy = -thickness; gy <= thickness; gy++) {
          for (let gx = -thickness; gx <= thickness; gx++) {
            const px = Math.floor(x + gx);
            const py = Math.floor(y + gy);
            
            if (px >= 0 && px < width && py >= 0 && py < height) {
              const idx2 = (py * width + px) * 4;
              const dist = Math.sqrt(gx * gx + gy * gy);
              if (dist <= thickness) {
                const intensity = 1 - dist / thickness;
                data[idx2] = Math.min(255, data[idx2] + 180 * intensity);
                data[idx2 + 1] = Math.min(255, data[idx2 + 1] + 200 * intensity);
                data[idx2 + 2] = Math.min(255, data[idx2 + 2] + 255 * intensity);
              }
            }
          }
        }
      }
    }
  }
}

function applySubatomicShuffle(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const particles = 1000;
  
  for (let i = 0; i < particles; i++) {
    const x1 = Math.floor(Math.random() * width);
    const y1 = Math.floor(Math.random() * height);
    const x2 = Math.floor(Math.random() * width);
    const y2 = Math.floor(Math.random() * height);
    
    const idx1 = (y1 * width + x1) * 4;
    const idx2 = (y2 * width + x2) * 4;
    
    const temp = [data[idx1], data[idx1 + 1], data[idx1 + 2]];
    data[idx1] = data[idx2];
    data[idx1 + 1] = data[idx2 + 1];
    data[idx1 + 2] = data[idx2 + 2];
    data[idx2] = temp[0];
    data[idx2 + 1] = temp[1];
    data[idx2 + 2] = temp[2];
  }
}

function applyVideoStatic(imageData) {
  const data = imageData.data;
  const amount = staticAmount / 100; 
  
  for (let i = 0; i < data.length; i += 4) {
    if (Math.random() < amount) {
      const noise = Math.random() * 255;
      
      data[i] = noise;     
      data[i + 1] = noise; 
      data[i + 2] = noise; 
    }
  }
}

document.getElementById('videoStatic').addEventListener('click', e => toggleEffect('videoStatic', e.target));
document.getElementById('staticAmount').addEventListener('input', e => {
  staticAmount = parseInt(e.target.value);
});

function applyBrightness(imageData) {
  const data = imageData.data;
  const brightnessValue = parseInt(document.getElementById('brightness').value);
  const adjustment = 255 * (brightnessValue / 100);
  for (let i = 0; i < data.length; i += 4) {
    data[i] = Math.min(255, Math.max(0, data[i] + adjustment));
    data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + adjustment));
    data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + adjustment));
  }
}

function makeDistortionCurve(amount) {
  const samples = 44100;
  const curve = new Float32Array(samples);
  const deg = Math.PI / 180;
  for (let i = 0; i < samples; ++i) {
    const x = i * 2 / samples - 1;
    curve[i] = (3 + amount) * x * 20 * deg / (Math.PI + amount * Math.abs(x));
  }
  return curve;
}

async function reverseAudio() {
  if (!audioContext || !source) return;
  
  const response = await fetch(video.src);
  const arrayBuffer = await response.arrayBuffer();
  audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
  
  const reversedBuffer = audioContext.createBuffer(
    audioBuffer.numberOfChannels,
    audioBuffer.length,
    audioBuffer.sampleRate
  );
  
  for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
    const channelData = audioBuffer.getChannelData(channel);
    const reversedData = reversedBuffer.getChannelData(channel);
    for (let i = 0; i < channelData.length; i++) {
      reversedData[i] = channelData[channelData.length - 1 - i];
    }
  }
  
  source.disconnect();
  const newSource = audioContext.createBufferSource();
  newSource.buffer = audioReversed ? audioBuffer : reversedBuffer;
  newSource.connect(distortionNode);
  newSource.start();
  source = newSource;
  
  audioReversed = !audioReversed;
}

document.getElementById('audioReverse').addEventListener('click', reverseAudio);

document.getElementById('mathGlitch').addEventListener('click', e => toggleEffect('mathGlitch', e.target));
document.getElementById('cellularAutomata').addEventListener('click', e => toggleEffect('cellularAutomata', e.target));
document.getElementById('edgeDetection').addEventListener('click', e => toggleEffect('edgeDetection', e.target));
document.getElementById('kaleidoscope').addEventListener('click', e => toggleEffect('kaleidoscope', e.target));
document.getElementById('oilPainting').addEventListener('click', e => toggleEffect('oilPainting', e.target));
document.getElementById('pixelBleed').addEventListener('click', e => toggleEffect('pixelBleed', e.target));
document.getElementById('magneticField').addEventListener('click', e => toggleEffect('magneticField', e.target));
document.getElementById('energySpiral').addEventListener('click', e => toggleEffect('energySpiral', e.target));
document.getElementById('quantumFlux').addEventListener('click', e => toggleEffect('quantumFlux', e.target));
document.getElementById('neonGlow').addEventListener('click', e => toggleEffect('neonGlow', e.target));
document.getElementById('liquidMetal').addEventListener('click', e => toggleEffect('liquidMetal', e.target));
document.getElementById('neuralGlitch').addEventListener('click', e => toggleEffect('neuralGlitch', e.target));
document.getElementById('voronoiBreak').addEventListener('click', e => toggleEffect('voronoiBreak', e.target));
document.getElementById('electricNoise').addEventListener('click', e => toggleEffect('electricNoise', e.target));
document.getElementById('subatomicShuffle').addEventListener('click', e => toggleEffect('subatomicShuffle', e.target));
document.getElementById('rgbToYuv').addEventListener('click', e => toggleEffect('rgbToYuv', e.target));
document.getElementById('yuvToRgb').addEventListener('click', e => toggleEffect('yuvToRgb', e.target));
document.getElementById('cumulativeMath').addEventListener('click', e => toggleEffect('cumulativeMath', e.target));
document.getElementById('literalSort').addEventListener('click', e => toggleEffect('literalSort', e.target));
document.getElementById('lowPass').addEventListener('click', e => toggleEffect('lowPass', e.target));
document.getElementById('lumiSort').addEventListener('click', e => toggleEffect('lumiSort', e.target));
document.getElementById('qamFault').addEventListener('click', e => toggleEffect('qamFault', e.target));
document.getElementById('threeDDisplace').addEventListener('click', e => toggleEffect('threeDDisplace', e.target));
document.getElementById('codeBlock').addEventListener('click', e => toggleEffect('codeBlock', e.target));
document.getElementById('tvNoise').addEventListener('click', e => toggleEffect('tvNoise', e.target));
document.getElementById('vhsTape').addEventListener('click', e => toggleEffect('vhsTape', e.target));
document.getElementById('dataCorruption').addEventListener('click', e => toggleEffect('dataCorruption', e.target));
document.getElementById('signalJammer').addEventListener('click', e => toggleEffect('signalJammer', e.target));
document.getElementById('crtEffect').addEventListener('click', e => toggleEffect('crtEffect', e.target));
document.getElementById('filmGrain').addEventListener('click', e => toggleEffect('filmGrain', e.target));
document.getElementById('oldMovie').addEventListener('click', e => toggleEffect('oldMovie', e.target));
document.getElementById('fractalize').addEventListener('click', e => toggleEffect('fractalize', e.target));
document.getElementById('bloomEffect').addEventListener('click', e => toggleEffect('bloomEffect', e.target));
document.getElementById('deepfry').addEventListener('click', e => toggleEffect('deepfry', e.target));
document.getElementById('infrared').addEventListener('click', e => toggleEffect('infrared', e.target));
document.getElementById('nightVision').addEventListener('click', e => toggleEffect('nightVision', e.target));
document.getElementById('thermographics').addEventListener('click', e => toggleEffect('thermographics', e.target));
document.getElementById('radioWaves').addEventListener('click', e => toggleEffect('radioWaves', e.target));
document.getElementById('xray').addEventListener('click', e => toggleEffect('xray', e.target));
document.getElementById('vaporwave').addEventListener('click', e => toggleEffect('vaporwave', e.target));
document.getElementById('cyberpunk').addEventListener('click', e => toggleEffect('cyberpunk', e.target));
document.getElementById('glitchCore').addEventListener('click', e => toggleEffect('glitchCore', e.target));
document.getElementById('recursion').addEventListener('click', e => toggleEffect('recursion', e.target));
document.getElementById('pixelation3D').addEventListener('click', e => toggleEffect('pixelation3D', e.target));
document.getElementById('timeWarp').addEventListener('click', e => toggleEffect('timeWarp', e.target));
document.getElementById('fourthDimension').addEventListener('click', e => toggleEffect('fourthDimension', e.target));
document.getElementById('dataBending').addEventListener('click', e => toggleEffect('dataBending', e.target));
document.getElementById('circuitBreak').addEventListener('click', e => toggleEffect('circuitBreak', e.target));
document.getElementById('machineCode').addEventListener('click', e => toggleEffect('machineCode', e.target));
document.getElementById('artifactGeneration').addEventListener('click', e => toggleEffect('artifactGeneration', e.target));
document.getElementById('quantumEntanglement').addEventListener('click', e => toggleEffect('quantumEntanglement', e.target));
document.getElementById('matrixRain').addEventListener('click', e => toggleEffect('matrixRain', e.target));
document.getElementById('hologramGlitch').addEventListener('click', e => toggleEffect('hologramGlitch', e.target));
document.getElementById('sinWave').addEventListener('click', e => toggleEffect('sinWave', e.target));
document.getElementById('cosWave').addEventListener('click', e => toggleEffect('cosWave', e.target));
document.getElementById('tanWave').addEventListener('click', e => toggleEffect('tanWave', e.target));
document.getElementById('byteShift').addEventListener('click', e => toggleEffect('byteShift', e.target));
document.getElementById('harmonicDistortion').addEventListener('click', e => toggleEffect('harmonicDistortion', e.target));
document.getElementById('cellularShift').addEventListener('click', e => toggleEffect('cellularShift', e.target));
document.getElementById('digitalDecay').addEventListener('click', e => toggleEffect('digitalDecay', e.target));
document.getElementById('fractalMosaic').addEventListener('click', e => toggleEffect('fractalMosaic', e.target));

function applyRgbToYuv(imageData) {
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    
    const y = 0.299 * r + 0.587 * g + 0.114 * b;
    const u = 0.492 * (b - y);
    const v = 0.877 * (r - y);
    
    data[i] = y;     
    data[i + 1] = u + 128; 
    data[i + 2] = v + 128; 
  }
}

function applyYuvToRgb(imageData) {
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const y = data[i];
    const u = data[i + 1] - 128; 
    const v = data[i + 2] - 128; 
    
    const r = y + 1.140 * v;
    const g = y - 0.395 * u - 0.581 * v;
    const b = y + 2.032 * u;
    
    data[i] = Math.min(255, Math.max(0, r));
    data[i + 1] = Math.min(255, Math.max(0, g));
    data[i + 2] = Math.min(255, Math.max(0, b));
  }
}

function applyCumulativeMath(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  let sumR = 0, sumG = 0, sumB = 0;
  
  for (let i = 0; i < data.length; i += 4) {
    sumR += data[i];
    sumG += data[i + 1];
    sumB += data[i + 2];
    
    data[i] = sumR % 256;
    data[i + 1] = sumG % 256;
    data[i + 2] = sumB % 256;
  }
}

function applyLiteralSort(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  for (let y = 0; y < height; y += 10) {
    if (Math.random() < 0.3) continue;
    
    for (let x = 0; x < width; x += 8) {
      if (Math.random() < 0.7) {
        const value = Math.floor(Math.random() * 256);
        
        for (let by = 0; by < 8 && y + by < height; by++) {
          for (let bx = 0; bx < 8 && x + bx < width; bx++) {
            const idx = ((y + by) * width + (x + bx)) * 4;
            
            data[idx] = 10;
            data[idx + 1] = 255;
            data[idx + 2] = 10;
          }
        }
      }
    }
  }
}

function applyLowPass(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const tempData = new Uint8ClampedArray(data);
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      let sumR = 0, sumG = 0, sumB = 0, count = 0;
      
      for (let ky = -1; ky <= 1; ky++) {
        for (let kx = -1; kx <= 1; kx++) {
          const nx = x + kx;
          const ny = y + ky;
          
          if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
            const kernelIdx = (ny * width + nx) * 4;
            sumR += tempData[kernelIdx];
            sumG += tempData[kernelIdx + 1];
            sumB += tempData[kernelIdx + 2];
            count++;
          }
        }
      }
      
      data[idx] = sumR / count;
      data[idx + 1] = sumG / count;
      data[idx + 2] = sumB / count;
    }
  }
}

function applyLumiSort(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  for (let y = 0; y < height; y += 10) {
    const chunkStart = y * width * 4;
    const chunkEnd = chunkStart + width * 10 * 4;
    const pixels = [];
    
    for (let x = 0; x < width; x++) {
      const idx = chunkStart + x * 4;
      const luminance = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
      pixels.push({
        idx,
        luminance,
        color: [data[idx], data[idx + 1], data[idx + 2]]
      });
    }
    
    pixels.sort((a, b) => a.luminance - b.luminance);
    
    pixels.forEach((pixel, index) => {
      const targetIdx = chunkStart + index * 4;
      data[targetIdx] = pixel.color[0];
      data[targetIdx + 1] = pixel.color[1];
      data[targetIdx + 2] = pixel.color[2];
    });
  }
}

function applyQamFault(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    const phaseShift = Math.sin(y * 0.05 + time) * Math.PI;
    const amplitude = Math.cos(time * 0.5) * 0.5 + 0.5;
    
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const inPhase = Math.cos(x * 0.1 + phaseShift) * amplitude;
      const quadrature = Math.sin(x * 0.1 + phaseShift) * amplitude;
      
      data[idx] = data[idx] * inPhase + data[idx + 1] * quadrature;
      data[idx + 1] = data[idx + 1] * inPhase + data[idx] * quadrature;
      data[idx + 2] = data[idx + 2] * (inPhase + quadrature) / 2;
    }
  }
}

function applyThreeDDisplace(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const tempData = new Uint8ClampedArray(data);
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const z = Math.sin((x / width) * Math.PI * 2 + time) * Math.cos((y / height) * Math.PI * 2 + time) * 20;
      
      const sourceX = Math.min(Math.max(x + Math.floor(z), 0), width - 1);
      const sourceY = Math.min(Math.max(y + Math.floor(z), 0), height - 1);
      const sourceIdx = (sourceY * width + sourceX) * 4;
      
      data[idx] = tempData[sourceIdx];
      data[idx + 1] = tempData[sourceIdx + 1];
      data[idx + 2] = tempData[sourceIdx + 2];
    }
  }
}

function applyCodeBlock(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const blockSize = 20;
  
  for (let y = 0; y < height; y += blockSize) {
    for (let x = 0; x < width; x += blockSize) {
      if (Math.random() < 0.2) {
        for (let by = 0; by < blockSize && y + by < height; by++) {
          const isLine = Math.random() < 0.7; 
          
          if (isLine) {
            const lineLength = Math.floor(Math.random() * blockSize) + blockSize / 2;
            const lineOffset = Math.floor(Math.random() * (blockSize - lineLength));
            
            for (let bx = lineOffset; bx < lineOffset + lineLength && x + bx < width; bx++) {
              const idx = ((y + by) * width + (x + bx)) * 4;
              data[idx] = 20;     
              data[idx + 1] = 180; 
              data[idx + 2] = 30;  
            }
          }
        }
      }
    }
  }
}

function applyTvNoise(imageData) {
  const data = imageData.data;
  const noiseAmount = 0.3;
  
  for (let i = 0; i < data.length; i += 4) {
    if (Math.random() < noiseAmount) {
      const noise = Math.random() * 255;
      
      data[i] = noise;     
      data[i + 1] = noise; 
      data[i + 2] = noise; 
    }
  }
}

function applyVhsTape(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    const trackingError = Math.sin(y * 0.1 + time) * 10;
    const colorBleed = Math.sin(y * 0.05 + time * 0.5) * 5;
    
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const sourceX = Math.floor(x + trackingError) % width;
      const sourceIdx = (y * width + sourceX) * 4;
      
      data[idx] = data[sourceIdx]; 
      data[idx + 1] = data[sourceIdx + 1]; 
      data[idx + 2] = data[sourceIdx + 2]; 
      
      if (Math.random() < 0.1) {
        data[idx] = Math.random() * 255;
        data[idx + 1] = Math.random() * 255;
        data[idx + 2] = Math.random() * 255;
      }
    }
  }
}

function applyDataCorruption(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  for (let i = 0; i < 20; i++) { 
    const startY = Math.floor(Math.random() * height);
    const corruptionHeight = Math.floor(Math.random() * 50) + 10;
    const dataLoss = Math.random() < 0.5; 
    
    for (let y = startY; y < startY + corruptionHeight && y < height; y++) {
      if (dataLoss) {
        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          data[idx] = Math.random() * 255;
          data[idx + 1] = Math.random() * 255;
          data[idx + 2] = Math.random() * 255;
        }
      } else {
        const shift = Math.floor(Math.random() * 7) + 1; 
        
        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          data[idx] = (data[idx] << shift) & 255 | (data[idx] >> (8 - shift));
          data[idx + 1] = (data[idx + 1] << shift) & 255 | (data[idx + 1] >> (8 - shift));
          data[idx + 2] = (data[idx + 2] << shift) & 255 | (data[idx + 2] >> (8 - shift));
        }
      }
    }
  }
}

function applySignalJammer(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    const jamStrength = Math.sin(y * 0.05 + time * 2) * 0.5 + 0.5;
    const jamFreq = Math.cos(time) * 10 + 20;
    
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const jamPattern = Math.sin(x / jamFreq) * jamStrength;
      
      if (Math.abs(jamPattern) > 0.7) {
        data[idx] = Math.random() * 255;
        data[idx + 1] = Math.random() * 255;
        data[idx + 2] = Math.random() * 255;
      } else if (Math.abs(jamPattern) > 0.4) {
        data[idx] = 255 - data[idx];
        data[idx + 1] = data[idx + 1] * 0.5;
        data[idx + 2] = data[idx + 2] * 0.5;
      } else if (Math.abs(jamPattern) > 0.2) {
        data[idx] = data[idx] * 0.8 + 50;
        data[idx + 1] = data[idx + 1] * 0.8 + 50;
        data[idx + 2] = data[idx + 2] * 0.8 + 50;
      }
    }
  }
}

function applyCrtEffect(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    const scanlineFactor = (y % 2 === 0) ? 0.85 : 1.0;
    
    const flickerAmount = Math.sin(time * 10) * 0.05 + 0.95;
    
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const rFactor = 1.0, gFactor = 1.0, bFactor = 1.0;
      
      switch (x % 3) {
        case 0: rFactor = 1.2; break; 
        case 1: gFactor = 1.2; break; 
        case 2: bFactor = 1.2; break; 
      }
      
      data[idx] = data[idx] * rFactor * scanlineFactor * flickerAmount;
      data[idx + 1] = data[idx + 1] * gFactor * scanlineFactor * flickerAmount;
      data[idx + 2] = data[idx + 2] * bFactor * scanlineFactor * flickerAmount;
      
      const dx = x / width - 0.5;
      const dy = y / height - 0.5;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const vignette = 1 - dist * 1.5;
      
      if (vignette < 1) {
        data[idx] *= vignette;
        data[idx + 1] *= vignette;
        data[idx + 2] *= vignette;
      }
    }
  }
}

function applyFilmGrain(imageData) {
  const data = imageData.data;
  const grainAmount = 0.15;
  
  for (let i = 0; i < data.length; i += 4) {
    const grain = (Math.random() - 0.5) * grainAmount * 255;
    
    data[i] = Math.min(255, Math.max(0, data[i] + grain));
    data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + grain));
    data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + grain));
  }
}

function applyOldMovie(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    
    const sepia = (r * 0.393) + (g * 0.769) + (b * 0.189);
    data[i] = Math.min(255, sepia);
    data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
    data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
  }
  
  if (Math.random() < 0.3) {
    const scratchX = Math.floor(Math.random() * width);
    const scratchWidth = Math.floor(Math.random() * 3) + 1;
    
    for (let y = 0; y < height; y++) {
      for (let x = scratchX; x < scratchX + scratchWidth && x < width; x++) {
        const idx = (y * width + x) * 4;
        data[idx] = 255;
        data[idx + 1] = 255;
        data[idx + 2] = 255;
      }
    }
  }
  
  for (let i = 0; i < 100; i++) {
    const speckX = Math.floor(Math.random() * width);
    const speckY = Math.floor(Math.random() * height);
    const speckSize = Math.floor(Math.random() * 3) + 1;
    
    for (let y = 0; y < speckSize; y++) {
      for (let x = 0; x < speckSize; x++) {
        const newX = speckX + x;
        const newY = speckY + y;
        
        if (newX < width && newY < height) {
          const idx = (newY * width + newX) * 4;
          data[idx] = 0;
          data[idx + 1] = 0;
          data[idx + 2] = 0;
        }
      }
    }
  }
  
  if (Math.random() < 0.1) {
    for (let i = 0; i < data.length; i += 4) {
      data[i] *= 0.9;
      data[i + 1] *= 0.9;
      data[i + 2] *= 0.9;
    }
  }
}

function applyFractalize(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  const centerX = width / 2;
  const centerY = height / 2;
  const zoom = Math.sin(time * 0.5) * 0.5 + 1.5;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const zx = (x - centerX) / (width * 0.25) / zoom;
      const zy = (y - centerY) / (height * 0.25) / zoom;
      
      const c_real = Math.sin(time * 0.5) * 0.7;
      const c_imag = Math.cos(time * 0.3) * 0.7;
      
      let cx = zx;
      let cy = zy;
      let iteration = 0;
      const maxIteration = 20;
      
      while (cx * cx + cy * cy < 4 && iteration < maxIteration) {
        const aa = cx * cx - cy * cy + c_real;
        const bb = 2 * cx * cy + c_imag;
        cx = aa;
        cy = bb;
        iteration++;
      }
      
      if (iteration < maxIteration) {
        const smoothColor = iteration + 1 - Math.log(Math.log(cx * cx + cy * cy)) / Math.log(2);
        const hue = (smoothColor * 10 + time * 20) % 360;
        
        const [r, g, b] = hslToRgb(hue / 360, 0.8, 0.5);
        
        data[idx] = (data[idx] + r) / 2;
        data[idx + 1] = (data[idx + 1] + g) / 2;
        data[idx + 2] = (data[idx + 2] + b) / 2;
      }
    }
  }
}

function applyBloomEffect(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const tempData = new Uint8ClampedArray(data);
  
  const brightPixels = new Uint8ClampedArray(data.length);
  const threshold = 200;
  
  for (let i = 0; i < data.length; i += 4) {
    const brightness = (tempData[i] + tempData[i + 1] + tempData[i + 2]) / 3;
    if (brightness > threshold) {
      brightPixels[i] = tempData[i];
      brightPixels[i + 1] = tempData[i + 1];
      brightPixels[i + 2] = tempData[i + 2];
      brightPixels[i + 3] = tempData[i + 3];
    }
  }
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      let sumR = 0, sumG = 0, sumB = 0, count = 0;
      
      for (let ky = -10; ky <= 10; ky++) {
        for (let kx = -10; kx <= 10; kx++) {
          const nx = x + kx;
          const ny = y + ky;
          
          if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
            const kernelIdx = (ny * width + nx) * 4;
            sumR += brightPixels[kernelIdx];
            sumG += brightPixels[kernelIdx + 1];
            sumB += brightPixels[kernelIdx + 2];
            count++;
          }
        }
      }
      
      if (count > 0) {
        data[idx] = Math.min(255, tempData[idx] + sumR / count * 0.5);
        data[idx + 1] = Math.min(255, tempData[idx + 1] + sumG / count * 0.5);
        data[idx + 2] = Math.min(255, tempData[idx + 2] + sumB / count * 0.5);
      }
    }
  }
}

function applyDeepfry(imageData) {
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
    data[i] = Math.min(255, data[i] * 1.2);
    data[i + 1] = Math.min(255, data[i + 1] * 1.1);
    
    data[i] = Math.floor(data[i] / 32) * 32;
    data[i + 1] = Math.floor(data[i + 1] / 32) * 32;
    data[i + 2] = Math.floor(data[i + 2] / 32) * 32;
  }
}

function applyInfrared(imageData) {
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    
    const heat = (r + g + b) / 3;
    
    data[i] = heat * 0.1;     
    data[i + 1] = heat * 1.2;  
    data[i + 2] = heat * 0.3;  
  }
  
  for (let i = 0; i < data.length; i += 4) {
    if (Math.random() < 0.2) {
      const noise = Math.random() * 30;
      data[i] += noise * 0.1;
      data[i + 1] += noise * 0.5;
      data[i + 2] += noise * 0.1;
    }
  }
  
  for (let i = 0; i < 20; i++) {
    const x = Math.floor(Math.random() * width);
    const y = Math.floor(Math.random() * height);
    const radius = Math.floor(Math.random() * 5) + 2;
    
    for (let ry = -radius; ry <= radius; ry++) {
      for (let rx = -radius; rx <= radius; rx++) {
        const dist = rx * rx + ry * ry;
        if (dist <= radius * radius) {
          const newX = x + rx;
          const newY = y + ry;
          
          if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
            const idx = (newY * width + newX) * 4;
            const brightness = 1 - dist / (radius * radius);
            
            data[idx] += 50 * brightness;
            data[idx + 1] += 200 * brightness;
            data[idx + 2] += 50 * brightness;
          }
        }
      }
    }
  }
}

function applyNightVision(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    
    const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
    
    data[i] = brightness * 0.1;     
    data[i + 1] = brightness * 1.2;  
    data[i + 2] = brightness * 0.3;  
  }
  
  for (let i = 0; i < data.length; i += 4) {
    if (Math.random() < 0.2) {
      const noise = Math.random() * 30;
      data[i] += noise * 0.1;
      data[i + 1] += noise * 0.5;
      data[i + 2] += noise * 0.1;
    }
  }
  
  for (let i = 0; i < 20; i++) {
    const x = Math.floor(Math.random() * width);
    const y = Math.floor(Math.random() * height);
    const radius = Math.floor(Math.random() * 5) + 2;
    
    for (let ry = -radius; ry <= radius; ry++) {
      for (let rx = -radius; rx <= radius; rx++) {
        const dist = rx * rx + ry * ry;
        if (dist <= radius * radius) {
          const newX = x + rx;
          const newY = y + ry;
          
          if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
            const idx = (newY * width + newX) * 4;
            const brightness = 1 - dist / (radius * radius);
            
            data[idx] += 50 * brightness;
            data[idx + 1] += 200 * brightness;
            data[idx + 2] += 50 * brightness;
          }
        }
      }
    }
  }
}

function applyThermographics(imageData) {
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    
    const heat = (r + g + b) / 3;
    
    if (heat < 51) {
      data[i] = 0;
      data[i + 1] = 0;
      data[i + 2] = heat * 5;
    } else if (heat < 102) {
      data[i] = 0;
      data[i + 1] = heat - 51;
      data[i + 2] = 255;
    } else if (heat < 153) {
      data[i] = heat - 102;
      data[i + 1] = 255;
      data[i + 2] = 255 - (heat - 102);
    } else if (heat < 204) {
      data[i] = 255;
      data[i + 1] = 255 - (heat - 153);
      data[i + 2] = 0;
    } else {
      data[i] = 255;
      data[i + 1] = heat - 204;
      data[i + 2] = heat - 204;
    }
  }
}

function applyRadioWaves(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  const centerX = width / 2;
  const centerY = height / 2;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const dx = x - centerX;
      const dy = y - centerY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      const wave = Math.sin(distance * 0.1 - time * 3);
      const effect = wave * 0.5 + 0.5;
      
      data[idx] = data[idx] * (1 - effect) + 0 * effect;
      data[idx + 1] = data[idx + 1] * (1 - effect) + 100 * effect;
      data[idx + 2] = data[idx + 2] * (1 - effect) + 255 * effect;
    }
  }
}

function applyXray(imageData) {
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    
    const brightness = 255 - (r * 0.299 + g * 0.587 + b * 0.114);
    
    data[i] = brightness * 0.8;
    data[i + 1] = brightness * 0.9;
    data[i + 2] = brightness;
  }
  
  for (let i = 0; i < data.length; i += 4) {
    if (data[i] > 200 && data[i + 1] > 200 && data[i + 2] > 200) {
      data[i] = 255;
      data[i + 1] = 255;
      data[i + 2] = 255;
    } else if (data[i] < 50 && data[i + 1] < 50 && data[i + 2] < 50) {
      data[i] = 0;
      data[i + 1] = 0;
      data[i + 2] = 0;
    }
  }
}

function applyVaporwave(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    const scanlineEffect = y % 4 === 0 ? 0.9 : 1.0;
    
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      data[idx] = Math.min(255, data[idx] * 1.2); 
      data[idx + 1] = Math.min(255, data[idx + 1] * 0.8); 
      data[idx + 2] = Math.min(255, data[idx + 2] * 1.2); 
      
      const colorShift = Math.sin(x * 0.01 + time) * 0.5 + 0.5;
      data[idx] = data[idx] * (1 - colorShift) + (255 * colorShift);
      data[idx + 2] = data[idx + 2] * (1 - colorShift) + (255 * colorShift);
    }
  }
}

function applyCyberpunk(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      data[idx] = Math.min(255, data[idx] * 1.4);
      data[idx + 1] = Math.min(255, data[idx + 1] * 0.7);
      data[idx + 2] = Math.min(255, data[idx + 2] * 1.4);
      
      if (data[idx] > 170 && data[idx + 1] > 170 && data[idx + 2] > 170) {
        data[idx] = 255;
        data[idx + 1] = 255;
        data[idx + 2] = 255;
      } else if (data[idx] < 85 && data[idx + 1] < 85 && data[idx + 2] < 85) {
        data[idx] = 0;
        data[idx + 1] = 0;
        data[idx + 2] = 0;
      }
    }
  }
  
  for (let i = 0; i < data.length; i += 4) {
    if (data[i] > 200 && data[i + 1] > 200 && data[i + 2] > 200) {
      data[i] = 255;
      data[i + 1] = 255;
      data[i + 2] = 255;
    } else if (data[i] < 50 && data[i + 1] < 50 && data[i + 2] < 50) {
      data[i] = 0;
      data[i + 1] = 0;
      data[i + 2] = 0;
    }
  }
}

function applyGlitchCore(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  for (let y = 0; y < height; y++) {
    const rShift = Math.floor(Math.random() * 10) - 5;
    const gShift = Math.floor(Math.random() * 10) - 5;
    const bShift = Math.floor(Math.random() * 10) - 5;
    
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      const rPos = Math.min(Math.max(x + rShift, 0), width - 1);
      const gPos = Math.min(Math.max(x + gShift, 0), width - 1);
      const bPos = Math.min(Math.max(x + bShift, 0), width - 1);
      
      const rIdx = (y * width + rPos) * 4;
      const gIdx = (y * width + gPos) * 4;
      const bIdx = (y * width + bPos) * 4;
      
      data[idx] = data[rIdx];
      data[idx + 1] = data[gIdx + 1];
      data[idx + 2] = data[bIdx + 2];
    }
  }
  
  for (let i = 0; i < 10; i++) {
    const blockX = Math.floor(Math.random() * width);
    const blockY = Math.floor(Math.random() * height);
    const blockW = Math.floor(Math.random() * 30) + 10;
    const blockH = Math.floor(Math.random() * 30) + 10;
    
    for (let y = blockY; y < blockY + blockH && y < height; y++) {
      for (let x = blockX; x < blockX + blockW && x < width; x++) {
        const idx = (y * width + x) * 4;
        
        if (Math.random() < 0.5) {
          data[idx] = Math.random() * 255;
          data[idx + 1] = Math.random() * 255;
          data[idx + 2] = Math.random() * 255;
        } else {
          const blockSize = 4;
          const bx = Math.floor(x / blockSize) * blockSize;
          const by = Math.floor(y / blockSize) * blockSize;
          const blockIdx = (by * width + bx) * 4;
          
          data[idx] = data[blockIdx];
          data[idx + 1] = data[blockIdx + 1];
          data[idx + 2] = data[blockIdx + 2];
        }
      }
    }
  }
  
  for (let y = 0; y < height; y++) {
    if (Math.random() < 0.1) {
      const offset = Math.floor(Math.random() * 20) - 10;
      const height = Math.floor(Math.random() * 3) + 1;
      
      for (let ty = y; ty < y + height && ty < height; ty++) {
        for (let x = 0; x < width; x++) {
          const sourceX = (x + offset + width) % width;
          const idx = (ty * width + x) * 4;
          const sourceIdx = (ty * width + sourceX) * 4;
          
          data[idx] = data[sourceIdx];
          data[idx + 1] = data[sourceIdx + 1];
          data[idx + 2] = data[sourceIdx + 2];
        }
      }
    }
  }
}

function applyRecursion(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const recursionLevels = 3;
  const scale = 0.4;
  
  const tempData = new Uint8ClampedArray(data);
  
  for (let level = 1; level <= recursionLevels; level++) {
    const scaleFactor = Math.pow(scale, level);
    const offsetX = width * (1 - scaleFactor) / 2;
    const offsetY = height * (1 - scaleFactor) / 2;
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        
        const subX = Math.floor(offsetX + x * scaleFactor);
        const subY = Math.floor(offsetY + y * scaleFactor);
        
        if (subX >= 0 && subX < width && subY >= 0 && subY < height) {
          const subIdx = (subY * width + subX) * 4;
          
          const alpha = 0.3;
          data[idx] = data[idx] * (1 - alpha) + tempData[subIdx] * alpha;
          data[idx + 1] = data[idx + 1] * (1 - alpha) + tempData[subIdx + 1] * alpha;
          data[idx + 2] = data[idx + 2] * (1 - alpha) + tempData[subIdx + 2] * alpha;
        }
      }
    }
  }
}

function applyPixelation3D(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  const pixelSize = 10;
  const depthScale = 20;
  
  for (let y = 0; y < height; y += pixelSize) {
    for (let x = 0; x < width; x += pixelSize) {
      const r = data[(y * width + x) * 4];
      const g = data[(y * width + x) * 4 + 1];
      const b = data[(y * width + x) * 4 + 2];
      
      for (let py = y; py < Math.min(y + pixelSize, height); py++) {
        for (let px = x; px < Math.min(x + pixelSize, width); px++) {
          const idx = (py * width + px) * 4;
          data[idx] = r;
          data[idx + 1] = g;
          data[idx + 2] = b;
        }
      }
    }
  }
}

function applyTimeWarp(imageData) {
  if (frameBuffer.length < 5) return;
  
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    const warp = Math.sin(y * 0.05 + time) * frameBuffer.length * 0.5;
    const frameIdx = Math.floor(Math.abs(warp) % frameBuffer.length);
    const pastFrame = frameBuffer[frameIdx];
    
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      if (Math.random() < Math.abs(Math.sin(x * 0.01 + time + warp))) {
        data[idx] = pastFrame.data[idx];
        data[idx + 1] = pastFrame.data[idx + 1];
        data[idx + 2] = pastFrame.data[idx + 2];
      }
    }
  }
}

function applyFourthDimension(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  const centerX = width / 2;
  const centerY = height / 2;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const dx = x - centerX;
      const dy = y - centerY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx);
      
      const w = Math.sin(time * 0.5) * 20;
      
      const newDist = distance * (1 + Math.sin(w * 0.1 + time));
      const newAngle = angle + Math.cos(distance * 0.05 + w * 2);
      
      const newX = Math.floor(centerX + Math.cos(newAngle) * newDist);
      const newY = Math.floor(centerY + Math.sin(newAngle) * newDist);
      
      if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
        const sourceIdx = (newY * width + newX) * 4;
        
        const shift = Math.sin(distance * 0.02 + w * 2);
        data[idx] = data[idx] * (1 + shift * 0.5);
        data[idx + 1] = data[idx + 1] * (1 - shift * 0.5);
        data[idx + 2] = data[idx + 2];
      }
    }
  }
}

function applyDataBending(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  const operations = [
    () => {
      const step = Math.floor(Math.random() * 10) + 2;
      for (let i = 0; i < data.length - step * 4; i += 4) {
        data[i] ^= data[i + step * 4];
        data[i + 1] ^= data[i + 1 + step * 4];
        data[i + 2] ^= data[i + 2 + step * 4];
      }
    },
    
    () => {
      for (let i = 0; i < data.length; i += 8) {
        if (i + 7 < data.length) {
          [data[i], data[i + 4]] = [data[i + 4], data[i]];
          [data[i + 1], data[i + 5]] = [data[i + 5], data[i + 1]];
          [data[i + 2], data[i + 6]] = [data[i + 6], data[i + 2]];
        }
      }
    },
    
    () => {
      const shift = Math.floor(Math.random() * 3);
      for (let i = 0; i < data.length; i += 4) {
        if (i + 4 < data.length) {
          [data[i], data[i + 1], data[i + 2]] = 
            [data[i + shift], data[i + 1 + shift], data[i + 2 + shift]];
        }
      }
    },
    
    () => {
      for (let i = 0; i < data.length; i += 4) {
        [data[i], data[i + 1], data[i + 2]] = 
          [data[i + 1], data[i + 2], data[i]];
      }
    }
  ];
  
  const numOps = Math.floor(Math.random() * 3) + 1;
  for (let i = 0; i < numOps; i++) {
    const opIndex = Math.floor(Math.random() * operations.length);
    operations[opIndex]();
  }
}

function applyCircuitBreak(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let i = 0; i < 8; i++) {
    const startX = Math.floor(Math.random() * width);
    const startY = Math.floor(Math.random() * height);
    
    let x = startX;
    let y = startY;
    const steps = Math.floor(Math.random() * 100) + 50;
    const thickness = Math.floor(Math.random() * 3) + 1;
    
    const color = [
      Math.random() * 100 + 155, 
      Math.random() * 100 + 155, 
      Math.random() * 100 + 155  
    ];
    
    for (let step = 0; step < steps; step++) {
      const t = step / steps;
      x = startX * (1 - t) + (Math.random() * width) * t + (Math.random() - 0.5) * 20;
      y = startY * (1 - t) + (Math.random() * height) * t + (Math.random() - 0.5) * 20;
      
      if (x >= 0 && x < width && y >= 0 && y < height) {
        const idx = (Math.floor(y) * width + Math.floor(x)) * 4;
        
        data[idx] = color[0];
        data[idx + 1] = color[1];
        data[idx + 2] = color[2];
        
        for (let gy = -thickness; gy <= thickness; gy++) {
          for (let gx = -thickness; gx <= thickness; gx++) {
            const px = Math.floor(x + gx);
            const py = Math.floor(y + gy);
            
            if (px >= 0 && px < width && py >= 0 && py < height) {
              const idx2 = (py * width + px) * 4;
              const dist = Math.sqrt(gx * gx + gy * gy);
              if (dist <= thickness) {
                const intensity = 1 - dist / thickness;
                data[idx2] = Math.min(255, data[idx2] + 100 * intensity);
                data[idx2 + 1] = Math.min(255, data[idx2 + 1] + 150 * intensity);
                data[idx2 + 2] = Math.min(255, data[idx2 + 2] + 255 * intensity);
              }
            }
          }
        }
      }
    }
  }
}

function applyMachineCode(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  for (let y = 0; y < height; y += 10) {
    if (Math.random() < 0.3) continue;
    
    for (let x = 0; x < width; x += 8) {
      if (Math.random() < 0.7) {
        const value = Math.floor(Math.random() * 256);
        
        for (let by = 0; by < 8 && y + by < height; by++) {
          for (let bx = 0; bx < 8 && x + bx < width; bx++) {
            const idx = ((y + by) * width + (x + bx)) * 4;
            
            data[idx] = 10;
            data[idx + 1] = 255;
            data[idx + 2] = 10;
          }
        }
      }
    }
  }
}

function applyArtifactGeneration(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  const blockSize = 8; 
  for (let y = 0; y < height; y += blockSize) {
    for (let x = 0; x < width; x += blockSize) {
      if (Math.random() < 0.3) { 
        const rSum = 0, gSum = 0, bSum = 0, count = 0;
        
        for (let by = 0; by < blockSize && y + by < height; by++) {
          for (let bx = 0; bx < blockSize && x + bx < width; bx++) {
            const idx = ((y + by) * width + (x + bx)) * 4;
            rSum += data[idx];
            gSum += data[idx + 1];
            bSum += data[idx + 2];
            count++;
          }
        }
        
        const rAvg = rSum / count;
        const gAvg = gSum / count;
        const bAvg = bSum / count;
        
        for (let by = 0; by < blockSize && y + by < height; by++) {
          for (let bx = 0; bx < blockSize && x + bx < width; bx++) {
            const idx = ((y + by) * width + (x + bx)) * 4;
            data[idx] = rAvg + (Math.random() - 0.5) * 30;
            data[idx + 1] = gAvg + (Math.random() - 0.5) * 30;
            data[idx + 2] = bAvg + (Math.random() - 0.5) * 30;
          }
        }
      }
    }
  }
  
  for (let i = 0; i < data.length; i += 4) {
    data[i] = Math.floor(data[i] / 32) * 32;
    data[i + 1] = Math.floor(data[i + 1] / 32) * 32;
    data[i + 2] = Math.floor(data[i + 2] / 32) * 32;
  }
  
  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      const idx = (y * width + x) * 4;
      const idxLeft = (y * width + (x - 1)) * 4;
      const idxRight = (y * width + (x + 1)) * 4;
      const idxUp = ((y - 1) * width + x) * 4;
      const idxDown = ((y + 1) * width + x) * 4;
      
      if (Math.abs(data[idx] - data[idxLeft]) > 32 || 
          Math.abs(data[idx] - data[idxRight]) > 32 || 
          Math.abs(data[idx] - data[idxUp]) > 32 || 
          Math.abs(data[idx] - data[idxDown]) > 32) {
        if (Math.random() < 0.5) {
          data[idx] = Math.random() * 255;
          data[idx + 1] = Math.random() * 255;
          data[idx + 2] = Math.random() * 255;
        }
      }
    }
  }
}

function applyQuantumEntanglement(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let i = 0; i < 50; i++) {
    const x1 = Math.floor(Math.random() * width);
    const y1 = Math.floor(Math.random() * height);
    const x2 = Math.floor(Math.random() * width);
    const y2 = Math.floor(Math.random() * height);
    const radius = Math.floor(Math.random() * 20) + 10;
    
    for (let dy = -radius; dy <= radius; dy++) {
      for (let dx = -radius; dx <= radius; dx++) {
        if (dx * dx + dy * dy < radius * radius) {
          const targetX = x1 + dx;
          const targetY = y1 + dy;
          
          if (targetX >= 0 && targetX < width && targetY >= 0 && targetY < height) {
            const idx1 = (targetY * width + targetX) * 4;
            const idx2 = (y2 * width + x2) * 4;
            
            if (Math.random() < 0.5) {
              data[idx1] = (data[idx1] + data[idx2]) / 2;
              data[idx1 + 1] = (data[idx1 + 1] + data[idx2 + 1]) / 2;
              data[idx1 + 2] = (data[idx1 + 2] + data[idx2 + 2]) / 2;
            } else if (Math.random() < 0.7) {
              data[idx1] = 255 - data[idx2];
              data[idx1 + 1] = 255 - data[idx2 + 1];
              data[idx1 + 2] = 255 - data[idx2 + 2];
            }
          }
        }
      }
    }
  }
}

function applyMatrixRain(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  const numDrops = width / 10;
  
  for (let dropIdx = 0; dropIdx < numDrops; dropIdx++) {
    const x = Math.floor(dropIdx * 10 + (Math.random() * 5 - 2.5));
    if (x < 0 || x >= width) continue;
    
    const startY = (time * 100 + dropIdx * 50) % (height * 2) - height;
    const dropLength = Math.floor(Math.random() * 20) + 10;
    
    for (let y = Math.floor(startY); y < Math.floor(startY + dropLength) && y < height; y++) {
      const idx = (y * width + x) * 4;
      
      data[idx] = 20;
      data[idx + 1] = 220;
      data[idx + 2] = 20;
    }
    
    const headY = Math.floor(startY);
    if (headY >= 0 && headY < height) {
      const idx = (headY * width + x) * 4;
      data[idx] = 255;
      data[idx + 1] = 255;
      data[idx + 2] = 255;
    }
  }
}

function applyHologramGlitch(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    const scanline = Math.sin(y * 0.1 + time * 3) * 0.5 + 0.5;
    
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      data[idx] = data[idx] * (1 - scanline) + 0 * scanline;
      data[idx + 1] = data[idx + 1] * (1 - scanline) + 100 * scanline;
      data[idx + 2] = data[idx + 2] * (1 - scanline) + 255 * scanline;
    }
  }
  
  for (let y = 0; y < height; y++) {
    if (Math.sin(y * 0.2 + time * 2) > 0.7) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        data[idx] = Math.min(255, data[idx] + 50);
        data[idx + 1] = Math.min(255, data[idx + 1] + 50);
        data[idx + 2] = Math.min(255, data[idx + 2] + 50);
      }
    }
  }
  
  if (Math.sin(time * 10) > 0.9) {
    for (let i = 0; i < data.length; i += 4) {
      data[i] *= 1.2;
      data[i + 1] *= 1.2;
      data[i + 2] *= 1.2;
    }
  }
  
  if (Math.random() < 0.1) {
    const glitchY = Math.floor(Math.random() * height);
    const glitchHeight = Math.floor(Math.random() * 10) + 5;
    const offset = Math.floor(Math.random() * 20) - 10;
    
    for (let y = glitchY; y < glitchY + glitchHeight && y < height; y++) {
      for (let x = 0; x < width; x++) {
        const sourceX = (x + offset + width) % width;
        const idx = (y * width + x) * 4;
        const sourceIdx = (y * width + sourceX) * 4;
        
        data[idx] = data[sourceIdx];
        data[idx + 1] = data[sourceIdx + 1];
        data[idx + 2] = data[sourceIdx + 2];
      }
    }
  }
}

function applySinWave(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const wave = Math.sin(x * 0.05 + y * 0.05 + time * 2);
      const effect = wave * 0.5 + 0.5;
      
      data[idx] = data[idx] * (1 - effect) + (data[idx] * Math.sin(time)) * effect;
      data[idx + 1] = data[idx + 1] * (1 - effect) + (data[idx + 1] * Math.sin(time + 2)) * effect;
      data[idx + 2] = data[idx + 2] * (1 - effect) + (data[idx + 2] * Math.sin(time + 4)) * effect;
    }
  }
}

function applyCosWave(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const wave = Math.cos(x * 0.05 + y * 0.05 + time * 2);
      const effect = wave * 0.5 + 0.5;
      
      data[idx] = data[idx] * (1 - effect) + (data[idx] * Math.cos(time)) * effect;
      data[idx + 1] = data[idx + 1] * (1 - effect) + (data[idx + 1] * Math.cos(time + 2)) * effect;
      data[idx + 2] = data[idx + 2] * (1 - effect) + (data[idx + 2] * Math.cos(time + 4)) * effect;
    }
  }
}

function applyTanWave(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const angle = (x / width) * Math.PI * 2 + time;
      const wave = Math.tan(angle);
      const effect = Math.min(1, wave * 0.2 + 0.5);
      
      data[idx] = data[idx] * (1 - effect) + (255 - data[idx]) * effect;
      data[idx + 1] = data[idx + 1] * (1 - effect) + (255 - data[idx + 1]) * effect;
      data[idx + 2] = data[idx + 2] * (1 - effect) + (255 - data[idx + 2]) * effect;
    }
  }
}

function applyByteShift(imageData) {
  const data = imageData.data;
  const pixelCount = data.length / 4;
  
  const blockSize = 100;
  const numBlocks = Math.floor(pixelCount / blockSize);
  
  for (let b = 0; b < numBlocks; b++) {
    if (Math.random() < 0.1) {
      const blockStart = b * blockSize * 4;
      const shift = Math.floor(Math.random() * 3);
      
      for (let i = 0; i < blockSize * 4; i += 4) {
        if (blockStart + i + 4 < data.length) {
          data[blockStart + i] = data[blockStart + i + shift];
          data[blockStart + i + 1] = data[blockStart + i + 1 + shift];
          data[blockStart + i + 2] = data[blockStart + i + 2 + shift];
        }
      }
    }
  }
  
  for (let i = 0; i < 500; i++) {
    const pos1 = Math.floor(Math.random() * (data.length - 4));
    const pos2 = Math.floor(Math.random() * (data.length - 4));
    
    data[pos1] = data[pos2];
    data[pos2] = data[pos1];
  }
  
  if (Math.random() < 0.3) {
    const offset = Math.floor(Math.random() * 100);
    const tempData = new Uint8ClampedArray(data);
    
    for (let i = 0; i < data.length - offset; i++) {
      data[i] = tempData[i + offset];
    }
  }
}

function applyHarmonicDistortion(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  for (let y = 0; y < height; y++) {
    const wave = Math.sin(y * 0.1 + time) * 20;
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const harmonic1 = Math.sin(x * 0.02 + time);
      const harmonic2 = Math.sin(x * 0.05 + time * 1.5) * 0.5;
      const harmonic3 = Math.sin(x * 0.1 + time * 0.7) * 0.25;
      
      const compound = (harmonic1 + harmonic2 + harmonic3) / 1.75;
      const distortionY = Math.floor(compound * 10);
      
      const sourceY = Math.max(0, Math.min(height - 1, y + distortionY));
      const sourceIdx = (sourceY * width + x) * 4;
      
      data[idx] = data[sourceIdx] * (1 + harmonic1 * 0.2);
      data[idx + 1] = data[sourceIdx + 1] * (1 + harmonic2 * 0.2);
      data[idx + 2] = data[sourceIdx + 2] * (1 + harmonic3 * 0.2);
    }
  }
}

function applyCellularShift(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  if (!window.cellularState) {
    window.cellularState = new Uint8Array(width * height);
    for (let i = 0; i < window.cellularState.length; i++) {
      if (Math.random() < 0.1) {
        window.cellularState[i] = 1;
      } else {
        window.cellularState[i] = 0;
      }
    }
  }
  
  const newState = new Uint8Array(window.cellularState);
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const i = y * width + x;
      
      let count = 0;
      
      for (let ny = -1; ny <= 1; ny++) {
        for (let nx = -1; nx <= 1; nx++) {
          const nx2 = x + nx + width;
          const ny2 = y + ny + height;
          const ni = (ny2 % height) * width + (nx2 % width);
          if (window.cellularState[ni] === 1) count++;
        }
      }
      
      if (count > 3) {
        newState[i] = 1;
      }
    }
  }
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const i = y * width + x;
      const idx = i * 4;
      
      if (newState[i] === 1) {
        const shiftX = Math.floor(Math.random() * 10) - 5;
        const shiftY = Math.floor(Math.random() * 10) - 5;
        
        const sourceX = Math.min(Math.max(x + shiftX, 0), width - 1);
        const sourceY = Math.min(Math.max(y + shiftY, 0), height - 1);
        const sourceIdx = (sourceY * width + sourceX) * 4;
        
        data[idx] = data[sourceIdx];
        data[idx + 1] = data[sourceIdx + 1];
        data[idx + 2] = data[sourceIdx + 2];
      }
    }
  }
  
  window.cellularState = newState;
}

function applyDigitalDecay(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  
  if (!window.decayMap) {
    window.decayMap = new Uint8Array(width * height);
    for (let i = 0; i < window.decayMap.length; i++) {
      window.decayMap[i] = Math.floor(Math.random() * 50) + 50;
    }
  }
  
  const newDecay = new Uint8Array(window.decayMap);
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const i = y * width + x;
      
      window.decayMap[i] = Math.max(0, window.decayMap[i] - Math.floor(Math.random() * 3));
      
      if (window.decayMap[i] > 0) {
        const idx = i * 4;
        
        const decayStrength = window.decayMap[i] / 100;
        
        if (decayStrength > 0.7) {
          data[idx] = 0;
          data[idx + 1] = 0;
          data[idx + 2] = 0;
        } else if (decayStrength > 0.4) {
          data[idx] = data[idx] * 0.8;
          data[idx + 1] = data[idx + 1] * 0.8;
          data[idx + 2] = data[idx + 2] * 0.8;
        } else if (decayStrength > 0.2) {
          data[idx] = data[idx] * 0.9;
          data[idx + 1] = data[idx + 1] * 0.9;
          data[idx + 2] = data[idx + 2] * 0.9;
        } else {
          const noise = (Math.random() - 0.5) * 20 * decayStrength;
          data[idx] += noise;
          data[idx + 1] += noise;
          data[idx + 2] += noise;
        }
      }
    }
  }
  
  if (Math.random() < 0.05) {
    for (let i = 0; i < 5; i++) {
      const x = Math.floor(Math.random() * width);
      const y = Math.floor(Math.random() * height);
      newDecay[y * width + x] = Math.floor(Math.random() * 50) + 50;
    }
  }
  
  window.decayMap = newDecay;
}

function applyFractalMosaic(imageData) {
  const data = imageData.data;
  const width = imageData.width;
  const height = imageData.height;
  const time = Date.now() * 0.001;
  
  const centerX = width / 2;
  const centerY = height / 2;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      
      const zx = (x - centerX) / (width * 0.25);
      const zy = (y - centerY) / (height * 0.25);
      
      const c_real = Math.sin(time) * 0.7;
      const c_imag = Math.cos(time * 1.5) * 0.7;
      
      let cx = zx;
      let cy = zy;
      let iteration = 0;
      const maxIteration = 20;
      
      while (cx * cx + cy * cy < 4 && iteration < maxIteration) {
        const aa = cx * cx - cy * cy + c_real;
        const bb = 2 * cx * cy + c_imag;
        cx = aa;
        cy = bb;
        iteration++;
      }
      
      if (iteration < maxIteration) {
        const smoothColor = iteration + 1 - Math.log(Math.log(cx * cx + cy * cy)) / Math.log(2);
        const hue = (smoothColor * 10 + time * 20) % 360;
        
        const [r, g, b] = hslToRgb(hue / 360, 0.8, 0.5);
        
        const cellX = Math.floor(x / 10) * 10;
        const cellY = Math.floor(y / 10) * 10;
        const cellIdx = (cellY * width + cellX) * 4;
        
        data[idx] = data[cellIdx];
        data[idx + 1] = data[cellIdx + 1];
        data[idx + 2] = data[cellIdx + 2];
        
        if (Math.random() < 0.1) {
          data[idx] = 255 - data[idx];
          data[idx + 1] = 255 - data[idx + 1];
          data[idx + 2] = 255 - data[idx + 2];
        }
      }
    }
  }
}
</script>
</body>
</html>
